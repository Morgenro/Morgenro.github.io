<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>二战 | Morgenro's Blog</title><meta name="author" content="Morgenro"><meta name="copyright" content="Morgenro"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="408数一英一考研笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="二战">
<meta property="og:url" content="http://example.com/2025/05/09/%E4%BA%8C%E6%88%98/index.html">
<meta property="og:site_name" content="Morgenro&#39;s Blog">
<meta property="og:description" content="408数一英一考研笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/AiHaibara1.jpg">
<meta property="article:published_time" content="2025-05-09T14:03:04.000Z">
<meta property="article:modified_time" content="2025-09-04T13:59:44.258Z">
<meta property="article:author" content="Morgenro">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/AiHaibara1.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "二战",
  "url": "http://example.com/2025/05/09/%E4%BA%8C%E6%88%98/",
  "image": "http://example.com/img/AiHaibara1.jpg",
  "datePublished": "2025-05-09T14:03:04.000Z",
  "dateModified": "2025-09-04T13:59:44.258Z",
  "author": [
    {
      "@type": "Person",
      "name": "Morgenro",
      "url": "http://example.com/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/AiHaibara1.jpg"><link rel="canonical" href="http://example.com/2025/05/09/%E4%BA%8C%E6%88%98/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":true},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二战',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/life-pages.css?1"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/img/AiHaibara1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/"><i class="fa-fw fa fa-folder-open"></i><span> 日记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/novel/"><i class="fa-fw fas fa-book"></i><span> 小说推荐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/AiHaibara1.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">Morgenro's Blog</span></a><a class="nav-page-title" href="/"><span class="site-name">二战</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/diary/"><i class="fa-fw fa fa-folder-open"></i><span> 日记</span></a></li><li><a class="site-page child" href="/photos/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/novel/"><i class="fa-fw fas fa-book"></i><span> 小说推荐</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">二战</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-05-09T14:03:04.000Z" title="发表于 2025-05-09 22:03:04">2025-05-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-04T13:59:44.258Z" title="更新于 2025-09-04 21:59:44">2025-09-04</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

<ul>
<li><a href="#408">408</a><ul>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84">数据结构</a><ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E8%A1%A8">线性表</a></li>
<li><a href="#%E6%A0%88-%E9%98%9F%E5%88%97-%E6%95%B0%E7%BB%84">栈、队列、数组</a></li>
<li><a href="#%E4%B8%B2">串</a></li>
<li><a href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91">树与二叉树</a><ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%A0%91">二叉树</a></li>
<li><a href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97">树和森林</a></li>
<li><a href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81">哈夫曼树和哈夫曼编码</a></li>
</ul>
</li>
<li><a href="#%E5%9B%BE">图</a><ul>
<li><a href="#%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98">图的储存</a></li>
<li><a href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86">图的遍历</a></li>
<li><a href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8">图的应用</a><ul>
<li><a href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91">最小生成树</a></li>
<li><a href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84">最短路径</a></li>
<li><a href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F">拓扑排序</a></li>
<li><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84">关键路径</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%9F%A5%E6%89%BE">查找</a><ul>
<li><a href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">顺序查找</a><ul>
<li><a href="#%E6%9C%89%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE">有序线性表的顺序查找</a></li>
</ul>
</li>
<li><a href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE">折半查找</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE">分块查找</a></li>
<li><a href="#%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE">树形查找</a><ul>
<li><a href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91">二叉排序树</a></li>
<li><a href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91">二叉平衡树</a></li>
<li><a href="#%E7%BA%A2%E9%BB%91%E6%A0%91">红黑树</a></li>
<li><a href="#b%E6%A0%91%E5%92%8Cb%E6%A0%91">B树和B+树</a></li>
<li><a href="#hash">Hash</a><ul>
<li><a href="#hash%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95">Hash的构造方法</a></li>
<li><a href="#hash%E7%9A%84%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E6%96%B9%E6%B3%95">Hash的处理冲突方法</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%8E%92%E5%BA%8F">排序</a><ul>
<li><a href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">插入排序</a></li>
<li><a href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F">交换排序</a></li>
<li><a href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">选择排序</a></li>
<li><a href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">二路归并排序</a></li>
<li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a></li>
<li><a href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F">外部排序</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86">计算机组成原理</a></li>
<li><a href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a></li>
<li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C">计算机网络</a></li>
</ul>
</li>
<li><a href="#%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6">高等数学</a><ul>
<li><a href="#%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD">函数极限与连续</a><ul>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%9E%81%E9%99%90">常用极限</a></li>
<li><a href="#%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F%E5%9C%A80%E5%A4%84">泰勒公式(在0处)</a></li>
<li><a href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93">题目总结</a></li>
<li><a href="#%E9%97%B4%E6%96%AD%E7%82%B9">间断点</a></li>
</ul>
</li>
<li><a href="#%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90">数列极限</a><ul>
<li><a href="#%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86">微分中值定理</a><ul>
<li><a href="#%E8%AF%81%E6%98%8E">证明：</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%A7%AF%E5%88%86%E5%BE%AE%E5%88%86">积分微分</a><ul>
<li><a href="#%E4%B8%80-%E5%9F%BA%E6%9C%AC%E7%A7%AF%E5%88%86">一、基本积分</a></li>
<li><a href="#%E4%BA%8C-%E6%AD%A3%E5%88%87%E4%B8%8E%E4%BD%99%E5%88%87%E7%A7%AF%E5%88%86">二、正切与余切积分</a></li>
<li><a href="#%E4%B8%89-%E5%B9%B3%E6%96%B9%E5%BD%A2%E5%BC%8F%E7%A7%AF%E5%88%86">三、平方形式积分</a></li>
<li><a href="#%E5%9B%9B-%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%A7%AF%E5%88%86">四、其他重要积分</a></li>
<li><a href="#%E4%BA%94-%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F">五、其他重要公式</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6">一元函数微分学</a><ul>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8">一元函数微分学-几何应用</a></li>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%E5%BE%AE%E5%88%86%E7%AD%89%E5%BC%8F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F">一元函数微分学-中值定理，微分等式与不等式</a></li>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E7%89%A9%E7%90%86%E5%BA%94%E7%94%A8">一元函数微分学-物理应用</a></li>
</ul>
</li>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6">一元函数积分学</a><ul>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%80%A7%E8%B4%A8">一元函数积分学的概念和性质</a></li>
<li><a href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%E7%9A%84%E8%AE%A1%E7%AE%97">一元函数积分学的计算</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6">多元函数微分学</a></li>
<li><a href="#%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B">微分方程</a><ul>
<li><a href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5">基础概念</a></li>
<li><a href="#%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98">相关习题</a></li>
</ul>
</li>
<li><a href="#%E5%A4%9A%E9%87%8D%E7%A7%AF%E5%88%86">多重积分</a><ul>
<li><a href="#%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86">二重积分</a></li>
<li><a href="#%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86">三重积分</a></li>
<li><a href="#%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86">曲线积分:</a><ul>
<li><a href="#%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86">闭合曲线积分:</a></li>
</ul>
</li>
<li><a href="#%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F">曲面积分一般形式:</a><ul>
<li><a href="#%E9%97%AD%E5%90%88%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86">闭合曲面积分</a></li>
</ul>
</li>
<li><a href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5">拉格朗日</a></li>
</ul>
</li>
<li><a href="#%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0">无穷级数</a><ul>
<li><a href="#%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0">傅里叶级数</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0">线性代数</a><ul>
<li><a href="#%E8%A1%8C%E5%88%97%E5%BC%8F">行列式</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5">矩阵</a><ul>
<li><a href="#%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5">转置矩阵</a></li>
<li><a href="#%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5">伴随矩阵</a></li>
<li><a href="#%E9%80%86%E7%9F%A9%E9%98%B5">逆矩阵</a></li>
<li><a href="#%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5">分块矩阵</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9">矩阵的秩!!!</a></li>
</ul>
</li>
<li><a href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84">线性方程组</a><ul>
<li><a href="#%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3%E6%97%A0%E5%85%B3%E8%A1%A8%E7%A4%BA">线性相关&#x2F;无关&#x2F;表示</a></li>
<li><a href="#%E5%9F%BA%E7%A1%80%E8%A7%A3%E7%B3%BB%E4%B8%8E%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84">基础解系与解的结构</a></li>
<li><a href="#%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4">施密特正交</a></li>
</ul>
</li>
<li><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E7%90%86%E8%AE%BA">矩阵相似理论</a></li>
<li><a href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%A7%92%E5%8C%96">矩阵相似对角化</a></li>
</ul>
</li>
</ul>
<!-- /code_chunk_output -->



<h1 id="408"><a href="#408" class="headerlink" title="408"></a>408</h1><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h3><p>相同数据类型有序数列</p>
<p>线性表特点：</p>
<ul>
<li>1、个数有限2、具有先后次序 3、都是数据元素，每个元素都是单个元素 4、数据类型相同 5、表中元素具有抽象性，讨论元素间逻辑关系。</li>
</ul>
<p><code>就像是数组不是线性表，因为无序</code></p>
<ul>
<li>顺序表 插入$\frac{n}{2}$,删除$\frac{n-1}{2}$，按值查找$\frac{n+1}{2}$</li>
</ul>
<h3 id="栈、队列、数组"><a href="#栈、队列、数组" class="headerlink" title="栈、队列、数组"></a>栈、队列、数组</h3><ul>
<li>栈：卡特兰数：当n个不同的元素入栈时，出栈元素不同排列个数为$\frac{1}{n+1}C_{2n}^n$</li>
<li>栈：1）设栈顶元素S.top&#x3D;-1 入栈时栈顶指针先加一再赋值<br>2）设栈顶S.top&#x3D;0 入栈时先赋值再栈顶指针加一</li>
<li>栈：中缀表达式转后缀<br>遇到“操作数”直接添加到输出列表，遇到符号时：<br>左括号 (：压入操作符栈。<br>右括号 )：弹出栈顶运算符并添加到输出列表，直到遇到左括号。<br>运算符（+, -, <em>, &#x2F; 等）：比较当前运算符与栈顶运算符的优先级：<br>  若栈为空或栈顶为 (：当前运算符压栈。<br>  若当前运算符优先级 高于 栈顶运算符：压栈。<br>  否则：弹出栈顶运算符到输出列表，重复比较直到满足压栈条件。<br>优先级规则：</em>&#x2F; &gt; +- &gt; (（乘除高于加减，括号最低）</li>
<li>特殊矩阵的存储：对称矩阵存一半，按行存，<br>三角矩阵（剩下一般是同一常量），也是一样的按行存，但是在最后留一个位置存入常量的大小<br>三对角矩阵也是按行优先存储，稀疏矩阵存对应的三元组：i，j，aij</li>
</ul>
<h3 id="串"><a href="#串" class="headerlink" title="串"></a>串</h3><p><code>串最重要的应该是KMP算法吧</code></p>
<ul>
<li>KMP算法：有主串长度n，模式串长度m，有简单模式匹配最多需要进行n-m+1次匹配，即：模式串最后一次正确匹配前每一个字符都要进行一次匹配<br>介绍KMP算法原理：“前缀”：除最后一个字符外，字符串的所有头部子串；“后缀”：除第一个字符外，所有的尾部子串；“部分匹配值”：字符串的前缀与后缀最长相等的前后缀长度<br>如“ababa”其部分匹配值为：‘a’：0；‘ab’：“a和b”相等长度为0；‘aba’：“a，ab”和“a，ba”相等长度为‘a’，1；‘abab’：‘a，ab，aba’和‘b，ab，bab’相等长度为2；‘ababa’相等长度为3<br>所以‘ababa’部分匹配值为00123<br>在KMP算法中，模式串右移的长度是“已匹配长度-对应的部分匹配值”<br>next数组的构建：部分匹配值加一后右移，<br>nextval数组：当$p_j&#x3D;p_{next[j]}$时，即要跳转的字符和该字符一样，必然失配，所以要一直递归直至$p_j&#x3D;p_{next[next[j]]}$，直至两者不相等为止</li>
</ul>
<h3 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h3><ul>
<li>树的性质<br>树的结点数 &#x3D; 所有结点的度数之和+1<br>度为m的树中第i层最多有$m^{i-1}$个结点：高度为h的m叉树最多有$1+m+m^2+…+m^{h-1}&#x3D;(m^h-1)&#x2F;(m-1)$个结点<br>相对应的，度为m，具有n个结点的树的最低高度为$log_m(n(m-1)+1)$,最大高度为n-m+1</li>
<li>度：一棵树中结点的最大度数是树的度</li>
</ul>
<h4 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h4><ul>
<li>二叉树是有序树</li>
<li>满二叉树：高度为h，且有2^h-1个结点，即满结点的二叉树</li>
<li>完全二叉树：高度为h，有n个结点的二叉树，当且仅当其每个结点和高度为h的满二叉树相对应，称之为完全二叉树</li>
<li>二叉排序树：左子树所有结点均小于根结点，右子树所有结点均大于根结点</li>
<li>二叉平衡树：树中任意一结点左右子树高度差不超过1</li>
<li>正则二叉树，每个分支结点只有0或2个孩子</li>
<li>二叉树的性质：高度为h的二叉树最多有2^h-1个结点<br>具有n个结点的完全二叉树，其高度为$[log_2(n+1)]或[log_2n]+1$</li>
<li>二叉树顺序存储的话依照完全二叉树存储，有空着的位置写0；<br>链式存储：lchild|data|rchild；左右孩指针，易验证：n个结点的二叉树有n+1个空链域</li>
<li>二叉树遍历：先序遍历：中左右；中序遍历：左中右；后序遍历：左右中；层次遍历：队列</li>
<li>线索二叉树：若无左子树，令lchild指向其前驱结点；若无rchild，令rchild指向其后驱结点<br>线索二叉树的结点结构：lchild|ltag|data|rtag|rchild<br>当tag为0时child指向子结点，当tag为1时指向前后驱<br><strong>前后驱的定义</strong>不是祖先这样的，而是遍历后的顺序，如中序遍历后‘BDAEC’则D的前驱是B，后驱是A，若D无左子树，则前驱指向B</li>
</ul>
<h4 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h4><ul>
<li>树的存储方法： <ul>
<li>双亲表示法：data|parent，后面存的是该结点父节点的序号，可以很快的得到该结点的父结点，但是求结点的孩子需要遍历整个结构</li>
<li>孩子表示法：将每个结点的孩子结点视为一个线性表，且以单链表作为储存结构，则n个结点就有n个孩子链表。结构为$data \rightarrow first_child \rightarrow second_child$</li>
<li>孩子兄弟表示法：也称二叉树表示法；结构为：指向第一个孩子的指针|结点值|结点右兄弟的指针</li>
</ul>
</li>
<li>树转化成二叉树：在兄弟结点间加一条线，对每个结点，只保留和第一个孩子的连线</li>
<li>森林转化成二叉树：先将每棵树转化成二叉树，然后将第二课树接在成第一颗树的右子树上</li>
<li>二叉树转换成森林：将根的右子树断开，然后树转二叉树</li>
</ul>
<h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ul>
<li>哈夫曼树：选取所有中最小的两位组成一个二叉子树。</li>
<li>哈夫曼编码：左分支为0，右分支为1，由此必得到前缀编码</li>
</ul>
<p><code>哈夫曼编码我印象中唯一的要记住的是：例如5 9 12 13 16组成是5+9=14；后不一定是必须要14和其他的数字组合，而是12和13组合</code></p>
<ul>
<li>并查集：通过树来实现集合的合并和遍历根是否一致来判断是否是同一个集合</li>
</ul>
<h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><ul>
<li>简单路径：顶点不重复出现的路径称之为简单路径</li>
<li>简单回路：出最后一个顶点和第一个顶点以外其余顶点不重复出现的回路称之为简单回路</li>
<li>距离：最短路径的长度</li>
<li>子图和生成子图：子图可以是原图中少几个顶点组成的图；生成子图的顶点必须和原图的顶点数一致</li>
<li>连通图；连通分量：图G中任意两个顶点都是连通的，称G为连通图；<strong>无向图</strong>中的<strong>极大连通子图</strong>称之为连通分量；连通分量不唯一；</li>
<li>强连通图；强连通分量：<strong>有向图</strong>中任意两个顶点都是连通的；有向图的极大强连通子图称之为强连通分量</li>
<li>生成树：包含图中全部顶点的极小连通子图</li>
<li>完全图：对于无向图，边的数量为0-n(n-1)&#x2F;2之间，对于有向图，边的数量从0-n(n-1)之间，有最大数量的边的图是完全图</li>
<li>有向树：一个顶点的入度为0，其余顶点的入度均为1的有向图称为有向树</li>
</ul>
<h4 id="图的储存"><a href="#图的储存" class="headerlink" title="图的储存"></a>图的储存</h4><ul>
<li>邻接矩阵：$A[i][j]&#x3D;1:(v_i,v_j)$是E（G）中的边；对于带权图来说，指$A[i][j]&#x3D;w_{ij}$<ul>
<li>有邻接矩阵为A，$A^n$的元素$A^n[i][j]$等于有顶点i到顶点j的长度为n的路径的个数</li>
<li>邻接矩阵适用于稠密图：即满足边的数量E&gt;|V|log2|V|</li>
</ul>
</li>
<li>邻接表法：<ul>
<li>邻接表法适用于稀疏图，即边相对较少</li>
<li>顶点$|DATA|firstarc|\rightarrow$依附于顶点的边（有向图指从这个顶点出发的边）</li>
<li>无向图储存空间O（V+2E），有向图O（V+E）</li>
</ul>
</li>
<li>十字链表：</li>
<li>十字链表是用来储存<strong>有向图</strong>的</li>
<li>十字链表的结构分为顶点结点和弧结点，顶点结点的结构是：data；firstin；firstout，分别是顶点名称，以该顶点为弧头的第一条弧（随意）和以该顶点为弧尾的第一条弧</li>
<li>弧结点的结构是：tailvex；headvex；hlink；tlink；（info）前两个分别存放弧尾和弧头这两个定点的编号；后两个分别指向弧头相同的下一条弧和弧尾相同的下一条弧</li>
<li>邻接多重表：<ul>
<li>邻接多重表是用来储存<strong>无向图</strong>的</li>
</ul>
</li>
</ul>
<p><code>我感觉就是顶点先指向一个依附于该顶点的边，然后在通过这个边结点指向其他有关于这个顶点的边；十字链表是指向同时以该顶点为出度/入度的边，邻接多重表则是和这顶点有连接就ok</code></p>
<h4 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h4><ul>
<li>广度优先搜索(BFS)：首先访问顶点v，然后依次访问未访问过的邻接顶点，直至图中所有顶点全部被访问过为止；如果依然有顶点未被访问，则另选一个未被访问过的顶点开始重复上述过程<ul>
<li>广度优先生成树：图的邻接矩阵唯一，所以其邻接矩阵的广度优先搜索树唯一；图的邻接表不唯一，所以邻接表的广度优先搜索树不唯一</li>
</ul>
</li>
</ul>
<p><code>广度优先生成树依赖于广度优先搜索的顺序，由于邻接矩阵其链表的自由的性质其搜索的顺序不唯一，所以其广度优先生成树不唯一</code></p>
<ul>
<li>深度优先搜索（DFS）：首先访问一起始顶点v，然后由v出发访问与v邻接但是未被访问的顶点w；重复上述，直到不能访问时依次退回到最近被访问的顶点，若其还有邻接顶点未被访问，则从该点开始继续重复上述搜索过程。</li>
<li>图的遍历与图的连通性：对于无向图来说，若仅需一次遍历就可以访问图中全部顶点，则无向图是联通的；对于有向图来说，正向图遍历一次加反向图遍历一次</li>
</ul>
<h4 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h4><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><ul>
<li>最小生成树：带权连通无向图中权值最小的生成树称之为最小生成树<ul>
<li>Prim算法：先选择任一顶点加入顶点T集合，然后选择一个与顶点T集合最近的未在集合T中的顶点和相应的边加入该顶点。以此类推</li>
<li>Kruskal算法：初始只有n个顶点，此时每个顶点自成一个连通分量，选择权值最小的边必须落在两个不同的连通分量中（使用并查集查询是否同一个顶点）</li>
</ul>
</li>
</ul>
<h5 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h5><ul>
<li>最短路径：两点中权值最短路径<ul>
<li>Dijkstra算法：(求某一点到其他点路径)<br>首先维护一个表，格式为:|结点|出发点|前结点|<br>第一步:从0(出发点)开始更新周围一步能到的结点;<br>第二步:选取<strong>未被标记中</strong>权重最近的结点<strong>标记</strong>;<br>第三步:从这个标记的节点出发更新一步能到的结点,如果有结点权重小于现在存储的权重则更新;<br>第四步:从<strong>未被标记中</strong>选取权重最近的结点<strong>标记</strong><br>第五步:以此类推</li>
<li>Froyd算法:(求任意两点最短路径)<ul>
<li>第k轮:第k行和第k列和主对角线元素不变</li>
<li>对应行列值相加和现有的比较,取小<br>例如 $$0 1 2 5\\infty 0 2 4\3 9 0 \infty\\infty 6 \infty 0$$经过第一步的更新后变成<br>$$0 1 2 5\\infty 0 2 4\3 4 0 8\\infty 6 \infty 0$$<br>最后有几个顶点就更新几次,最后算出的是任意两点间最短距离</li>
</ul>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>算法</th>
<th>无权图</th>
<th>带权图（非负权）</th>
<th>带负权图（无负权回路）</th>
<th>带负权回路图</th>
</tr>
</thead>
<tbody><tr>
<td>BFS</td>
<td>$O(V + E)$</td>
<td>不适用</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>Dijkstra</td>
<td>$O((V+E) \log V)$</td>
<td>$O((V+E) \log V)$</td>
<td>不适用</td>
<td>不适用</td>
</tr>
<tr>
<td>Floyd</td>
<td>$O(V^3)$</td>
<td>$O(V^3)$</td>
<td>$O(V^3)$</td>
<td>不适用（可检测负环）</td>
</tr>
</tbody></table>
<h5 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h5><ul>
<li>AOV网:若用有向无环图表示一个工程,其顶点表示活动,有向边&lt;vi,vj&gt;表示vi必须先于vj的这样一种关系.则将这种有向图称之为AOV网</li>
<li>拓扑排序:在一个有向无环图中,由一个有向无环图的顶点组成的排序,当且仅当满足<ol>
<li>每个顶点只出现一次</li>
<li>若顶点A在序列中排在B的前面,则在图中不存在从B到A的路径</li>
</ol>
</li>
<li>拓扑排序的方法:从AOV网中选择一个入度为0的点,并输出;然后删除和这个点有关的所有有向边;重复</li>
<li>拓扑排序时间复杂度:<br>邻接表O(V+E),邻接矩阵O(V^2)</li>
</ul>
<h5 id="关键路径"><a href="#关键路径" class="headerlink" title="关键路径"></a>关键路径</h5><ul>
<li>在带权有向图中,顶点表示事件,有向边表示活动;边上的权值表示完成该活动所需的事件.称之为AOE网(不是AOV网)AOV网的边上没有权重</li>
<li>关键活动指一个<strong>活动</strong>的最迟开始时间和其最早开始时间一致的活动</li>
<li>关键路径:所有的关键活动构成关键路径</li>
</ul>
<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><h4 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h4><ul>
<li>简单的从一头查找到另一头</li>
<li>平均成功查找长度:定位第i个元素时,$ASL_{成功}&#x3D;\frac{n+1}2$</li>
<li>平均失败查找长度:$ASL_{失败}&#x3D;n+1$</li>
</ul>
<h5 id="有序线性表的顺序查找"><a href="#有序线性表的顺序查找" class="headerlink" title="有序线性表的顺序查找"></a>有序线性表的顺序查找</h5><ul>
<li>有序线性表的顺序查找的平均成功查找长度和上述一致</li>
<li>有序线性表的顺序查找的平均失败查找长度:当第i个小于关键字,第i+1个大于关键字时,可以直接判断查找失败,$ASL_{不成功}&#x3D;\frac n2+\frac n{n+1}$</li>
</ul>
<h4 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h4><ul>
<li>仅适用于有序表</li>
<li>将定值和中间比,然后查其他两半</li>
<li>折半查找选取中间结点时,既可以采取向上取整,也可以采取向下取整,但每次查找的取整方式必须相同</li>
<li>可以构成折半查找判定树</li>
<li>平均查找成功长度为$\frac{n+1}{n}log_2(n+1)-1≈log_2(n+1)-1$</li>
</ul>
<h4 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h4><ul>
<li>块内元素可以无序,但是块间元素有序,即第一块中的最大关键词小于第二个块中所有关键字.有索引表,包含各块最大关键字和第一个元素地址.</li>
<li>第一步是索引块中折半或顺序,然后在块内顺序查找</li>
<li>长度为n的查找表均匀的分为b块,每块有s个,都顺序查找,$ASL&#x3D;\frac{b+1}2+\frac{s+1}2 &#x3D;\frac{s^2+2s+n}{2s}$当且仅当s&#x3D;$\sqrt n$时平均查找长度最小为$\sqrt n+1$</li>
</ul>
<h4 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h4><h5 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h5><ul>
<li>二叉排序树是为了方便插入和删除而不是为了检索</li>
<li>大小排序:左根右</li>
<li>二叉排序树的删除:<ul>
<li>叶结点直接删除</li>
<li>z只有一个左子树或右子树,则让子树替代z的位置</li>
<li>有左右两棵子树,则令z的直接前驱(或直接后驱替代)z,然后从二叉排序树中删去这个直接前驱(后驱)</li>
</ul>
</li>
</ul>
<h5 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h5><ul>
<li>定义:左子树和右子树的高度差相差不超过1</li>
<li>插入:插入后调整</li>
</ul>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><h5 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h5><h5 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h5><ul>
<li>将查找表中的关键字映射成该关键字对应的地址的函数</li>
<li>冲突:有可能会把两个及以上的关键字映射成同一个地址</li>
</ul>
<h6 id="Hash的构造方法"><a href="#Hash的构造方法" class="headerlink" title="Hash的构造方法"></a>Hash的构造方法</h6><ul>
<li>直接定址法:$H(key)&#x3D;a*k+b$,这种方法不会冲突,但是当关键字分布不连续,空位较多,会造成空间的浪费</li>
<li>除留余数法:$H(key)&#x3D;key \% p$ 假设散列表表长为m,则选取一个不大于m单最接近或等于m的质数p</li>
<li>数字分析法:设关键字是r进制数,r个数码在各位上出现的频率不一定相同,选取数码 较为均匀的若干位作为散列地址,</li>
<li>平方取中法:取关键字平方后中间几位作为散列地址</li>
</ul>
<h6 id="Hash的处理冲突方法"><a href="#Hash的处理冲突方法" class="headerlink" title="Hash的处理冲突方法"></a>Hash的处理冲突方法</h6><ul>
<li>开放定址法：表中的空闲地址开放，递推公式：$(H(key)+d_i)% m$其中$d_i$有下面四种取法<ol>
<li>$d_i$&#x3D;n</li>
<li>$d_i&#x3D;1^2,-1^2,2^2,-2^2…,n^2,-n^2$</li>
<li>$d_i&#x3D;i×Hash_2(key)$此方法需要两个哈希函数</li>
<li>$d_i&#x3D;伪随机数列$</li>
</ol>
</li>
<li>拉链法:所有的同义词存在一个线性链表中,这个线性链表尤其散列地址作为唯一标识</li>
<li>装填因子:$\alpha &#x3D; \frac{表中记录数n}{散列表长度m}$</li>
</ul>
<h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><ul>
<li>直接插入排序:查找前面的待插入位置k, 将有序序列中的待插入位置k后所有元素后移一个位置,将i复制为k.<ul>
<li>空间复杂度为O(1),时间复杂度O(n²),具有稳定性,即不会出现同一个位置相同元素位置发生变化.适用于链表和顺序表表</li>
</ul>
</li>
<li>折半插入排序:和直接插入排序的区别就是，直接插入排序是顺序查找，而折半插入是折半查找。插入的操作一致<ul>
<li>空间复杂度O(1),时间复杂度O(nlogn),稳定,只适用于顺序表</li>
</ul>
</li>
<li>希尔排序:先取一个小于增量$d_1$,把表中的数据分成$d_1$组,所有距离$d_1$的倍数的记录放在同一组,在各组内进行直接插入排序;在去第二个$d_2&lt; d_1$,重复上述过程,直到d&#x3D;1.最后直接进行一轮直接插入排序<ul>
<li>空间复杂度O(1),时间复杂度$O(n^{1.3})$,不稳定,只适用于顺序表</li>
</ul>
</li>
</ul>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><ul>
<li>冒泡排序:从后往前(或从前往后)两两比较相邻元素的值,若为逆序,则交换他们,直到最后一次没有交换<ul>
<li>空间复杂度:O(1),时间复杂度:$O(n^2)$,稳定,,适用于顺序存储和链式存储</li>
</ul>
</li>
<li>快速排序:首先选择一个元素作为枢轴，将这个元素的值保存。将这个元素的位置视作空位。头尾指针ij。首先从j开始往前找，找到元素小于枢轴，和枢轴换位置。在从i开始找元素大于枢轴的，在和枢轴换位置。直到i&#x3D;j<ul>
<li>空间O(1),时间最好$O(log_2n)$,最坏$O(n^2)$,平均$O(nlog_2n)$,不稳定,仅线性表.</li>
</ul>
</li>
</ul>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><ul>
<li>简单选择排序:第i趟排序和L(i)换位置,这样n-1轮即可获得排序<ul>
<li>空间O(1),时间$O(n^2)$,不稳定,链表和线性表都适用</li>
</ul>
</li>
<li>堆排序:<ul>
<li>堆的定义:1)L(i)≥L(2i)且L(i)≥L(2i+1)或2)L(i)≤L(2i)且L(i)≤L(2i+1);第一种叫大根堆,第二种叫小根堆;即任意非根结点小于等于其双亲结点和任意非根结点大于等于其双亲结点</li>
<li>堆排序的思路:堆满足根是极值,输出根后继续调整堆使其满足大小根堆</li>
<li>堆的初始化:从后往前处理,根和左右子结点进行交换选出符合要求的.</li>
<li>堆的删除,输出根后,将根和最后一个元素交换,然后调整堆</li>
<li>空间O(1),时间O(nlog2n)不稳定,只适用于顺序表</li>
</ul>
</li>
</ul>
<h4 id="二路归并排序"><a href="#二路归并排序" class="headerlink" title="二路归并排序"></a>二路归并排序</h4><p>有n个数据的表,视作n个子表,两两归并合成n&#x2F;2个有序表;继续两两归并</p>
<ul>
<li>归并的方法,由于是有序表归并,则设置两个指针,较小的一个输出并指针后移</li>
<li>空间O(n),时间O(nlog2n),稳定,适用于链表和有序表</li>
</ul>
<h4 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h4><p>不基于比较和移动进行排序,而是基于关键字的大小进行排序</p>
<ul>
<li>几进制就创造几个桶，首先从第一位开始，放入对应的桶中，在从1-10的顺序依次拿出。再根据第二位放入对应的桶中，重复上述。最大位数是几位就进行几轮</li>
<li>空间O(r),时间O(d(n+r)),d是最大位数,n是关键字个数,r是进制;稳定,适用于链表和线性表</li>
</ul>
<h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4><ul>
<li>前面都是内部排序,指数据都在内存中,文件常常是按块存储在磁盘中的,磁盘读写的机械动作往往时间远远超过在内存中进行运算的时间,所以外部排序主要考虑访问磁盘的次数,即I&#x2F;O次数</li>
</ul>
<h5 id="归并排序算法"><a href="#归并排序算法" class="headerlink" title="归并排序算法"></a>归并排序算法</h5><ul>
<li>首先将所有的数据均分为k个初始归并段，此时将所有的归并段输入到内存中，将初始归并段排序成段内有序，此时I&#x2F;O操作经历一次</li>
<li>在经历log2k次归并排序,最后生成最终结果.最后经历$(log_2k+1)n(n为数据块的数量)$次</li>
</ul>
<h5 id="多路归并排序与败者树"><a href="#多路归并排序与败者树" class="headerlink" title="多路归并排序与败者树"></a>多路归并排序与败者树</h5><ul>
<li>因为当k一旦增多,二路归并排序就需要进行多轮,增加了I&#x2F;O次数,此时增加归并路数就可以减少归并趟数从而减少I&#x2F;O次数</li>
<li>但是归并路数增多会导致每输出一个元素，都需要在 K 个元素中找到一个最小值。如果使用简单的线性比较，每次比较需要 K-1 次操作，总时间复杂度为 O(K*N)，当 K 很大时，CPU比较会成为瓶颈。这时就需要通过败者树进行</li>
<li>败者树实现:K个顺串组成叶结点,内部节点存储的是失败者,胜利者一直往根走,哪里胜出哪里从顺串补充.</li>
</ul>
<h5 id="置换-选择排序"><a href="#置换-选择排序" class="headerlink" title="置换-选择排序"></a>置换-选择排序</h5><ul>
<li>堆排序,先输出最小的到输出队列;如果后来的小于之前输出最小的,把这个后来的最小的冻结留到下一个输出队列输出.</li>
</ul>
<h5 id="最佳归并树"><a href="#最佳归并树" class="headerlink" title="最佳归并树"></a>最佳归并树</h5><ul>
<li>实现最佳归并树需要补充的虚段数:8个归并段进行3路归并:(8-1)%(3-1)&#x3D;1</li>
<li>手法类似于哈夫曼树</li>
</ul>
<h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="计算机系统概述"><a href="#计算机系统概述" class="headerlink" title="计算机系统概述"></a>计算机系统概述</h3><h4 id="计算机层次结构"><a href="#计算机层次结构" class="headerlink" title="计算机层次结构"></a>计算机层次结构</h4><ul>
<li>储存器：分为主储存器（也称内存或主存）和辅助存储器（也称外存）CPU可以直接访问主存。主存分为存储器地址存储器（MAR）和存储器数据存储器（MDR）。MAR存储访存地址，MDR存储读写数据。<br>MAR用于寻址，其位数反应最多可寻址的的存储单元的个数，如MAR为10位，则最多有1024个存储单元。MAR的长度和PC的长度相等</li>
</ul>
<p><code>MAR相当于一个酒店的房间号，这个酒店能住多少个人还是要看是几人间，所以总的来说是2^&#123;MAR&#125;*储存字长。而储存字长一般来说是1字节。对于32位系统来说，是2^32bytes，即4GB的内存</code></p>
<ul>
<li>运算器的组成：核心：算数逻辑单元（ALU），还包括若干通用寄存器，用于暂存中间数和操作数；如累加器（ACC）、乘商寄存器（MQ）、操作数寄存器（X）、变址寄存器（IX），基址寄存器（BR），程序状态存储器，也称标志存储器（PSW）</li>
<li>控制器的组成：由程序计数器PC，指令寄存器IR和控制单元CU组成。</li>
<li>CPU的组成：CPU一般由运算器和控制器组成，CPU包含ALU（算数逻辑单元），通用寄存器组（GPRs），标志寄存器（PSW，标志CF是否有进位借位；ZF：是否为0；SF：是否为负；OF：是否溢出），控制器，指令寄存器（IR），程序计数器（PC），MAR和MDR</li>
</ul>
<h5 id="计算机软件"><a href="#计算机软件" class="headerlink" title="计算机软件"></a>计算机软件</h5><ul>
<li>高级语言通过编译程序翻译成汇编语言或者是机器语言。汇编语言通过汇编程序翻译成机器语言。高级语言也通过解释程序顺序逐条翻译成机器指令并立即执行</li>
</ul>
<p><code>解释器相当于vscode点击运行按钮；编译器是链接成一个独立的可执行文件.exe</code></p>
<h4 id="计算机的性能指标"><a href="#计算机的性能指标" class="headerlink" title="计算机的性能指标"></a>计算机的性能指标</h4><ul>
<li>机器字长：32位，64位计算机的位数就是机器字长。一般等于ALU的宽度和寄存器的位数。通常选用1字节（8位）的整数倍</li>
<li>数据通路带宽：数据总线一次所能并行传送信息的位数。这里指的是外部信息总线</li>
<li>主存容量：2^{MAR}*MDR</li>
<li>运算速度：<br>时钟周期：CPU工作的最小时间单位，以相邻状态单元间的最大延迟时间作为基准，以指令流水线的每个流水段的最大延迟时间确定<br>主频：时钟周期的倒数，每秒有几个时钟周期<br>CPI：执行一条指令所需的时钟周期数<br>IPC：每秒执行多少条指令。IPS&#x3D;主频&#x2F;平均CPI<br>CPU执行时间&#x3D;CPU时钟周期数&#x2F;主频&#x3D;（指令条数*CPI）&#x2F;主频</li>
<li>大数字表示：在表述储存容量，文件大小时，K、M、G、T通常使用2的幂次表示，如1Kb&#x3D;2^10b。在描述速度速率时，k，M，G，T通常使用10的幂次表示，使用小写的k。</li>
<li>透明即不可见，就是不知道的意思</li>
</ul>
<h3 id="数据的表示和运算"><a href="#数据的表示和运算" class="headerlink" title="数据的表示和运算"></a>数据的表示和运算</h3><ul>
<li>十进制转二进制：<br>整数部分：除基取余：指除以要转换的进制。取余数位。最先取得余数是低位<br>小数部分：乘基取整：乘以要转换的进制。取整数位。最先取得的整数为高位</li>
<li>定点数的编码表示<br>真值：使用正负号表示正负数<br>机器数：分为原码，补码，反码，移码。指使用数字来表示正负的数<br><strong>在现代计算机中，通常使用补码来表示整数，原码小数来表示浮点数的尾数部分，用移码来表示浮点数的阶码</strong></li>
<li>原码：范围-（2^n-1）～2^n-1，有两个0的表示，加减法计算困难</li>
<li>反码：实现了2-3&#x3D;2+（-3），但是仍然存在两个0；<br>正数的反码是原码，负数的反码是对应正数的原码的按位取反<br>但是反码的计算中如果最高位有进位需要加到结果的最低位</li>
<li>补码：<br>正数的补码，反码，原码，完全相同<br>负数的补码是负数的反码再加一<br>范围：$-2^{n-1}~2^{n-1}-1$<ul>
<li>变形补码：为了判断运算结果是否溢出，采用双符号位补码。左符表示真正的符号位，右符用于判断是否溢出。</li>
</ul>
</li>
<li>移码：<br>主要是用于判断大小，表示浮点数的阶码<br>在真值X的基础上架上一个常数(偏置值)，通常这个常数取2^n-1,<br>移码和补码数值完全相同，只是符号位刚好相反<br>原码计算移码可以换成十进制加128再转换成2进制</li>
</ul>
<h4 id="整数类型和类型转换"><a href="#整数类型和类型转换" class="headerlink" title="整数类型和类型转换"></a>整数类型和类型转换</h4><ul>
<li>int型：short int 8位；int 32位；long int 32位机器中32位，64位机器中64位；有无符号通过在前面加上关键字unsigned 区分，默认有符号<br>char 8位，默认按无符号<br>上述都是通过补码存储</li>
<li>强制类型转换不改变各位位值，只改变解释这些位的方式</li>
<li>从小字长转换成大字长时，要对高位进行扩展。如果是无符号整数，则进行0扩展；如果是有符号整数，则进行符号扩展</li>
</ul>
<h4 id="运算方法和运算电器"><a href="#运算方法和运算电器" class="headerlink" title="运算方法和运算电器"></a>运算方法和运算电器</h4><ul>
<li>在带标志加法器中，溢出标志$OF&#x3D;C_n\oplus C_{n-1}$;符号表示SF判断正负，为1则为负；零标志ZF是0则表示结果不为0；进位借位标志CF&#x3D;C_{out}\oplus C_{in}</li>
<li>定点数的移位运算：<ol>
<li>逻辑移位：将操作数视作无符号整数，左移时，高位移出，低位补0；右移时，低位移出，高位补0。对于无符号数的逻辑左移，若高位1移出，则发生溢出</li>
<li>算数移位：将操作数看做有符号数，左移时，高位移出，低位补0，若溢出的高位不同与移位后的符号位，则发生溢出。右移时，低位移出，高位补符号位。若低位的1移出，则影响精度</li>
</ol>
</li>
</ul>
<h5 id="定点数的表示和运算"><a href="#定点数的表示和运算" class="headerlink" title="定点数的表示和运算"></a>定点数的表示和运算</h5><p>  加法，补码相加；减法，将被减数和减数的负数的补码相加。高位丢弃<br>  溢出判别方法：仅当两个符号相同的数相加或是两个符号相异的数相减才会发生溢出</p>
<ol>
<li>采用一位符号位：设A的符号是A，B的符号是B，运算结果的符号为S。溢出表达式：$V&#x3D;AB\bar{S}+\bar{A} \bar{B} S$,若V是0表示无溢出，若V是1，表示有溢出</li>
<li>采用双符号位：如果双符号相同则未溢出，如果双符号位不同，则有溢出</li>
<li>采用一位符号位的进位和最高数位的进位相同，则无溢出</li>
</ol>
<ul>
<li>标志符分析：<br>零标志ZF：对于无符号数和有符号数都有意义<br>溢出标志OF：对于无符号数来说没有意义。是反应有符号数是否溢出的。计算方法为$OF&#x3D;C_n \oplus C_{n-1}$<br>进&#x2F;借位标志CF：表示无符号数运算时有无借位，判断是否溢出；加法时CF&#x3D;1时表示溢出，减法时，通过CF&#x3D;NOT C_out判断是否溢出。不能判断有符号数是否溢出<br>符号标志SF：表示结果的符号，即F的最高位。对于无符号数无关</li>
<li>无符号数的比较：A-B：相等时ZF&#x3D;1；A&gt;B时ZF&#x3D;0，CF&#x3D;0；A &lt; B时ZF&#x3D;0，CF&#x3D;1</li>
<li>有符号数的比较：A-B：A&#x3D;B ZF&#x3D;1,SF&#x3D;0;A&gt;B ZF&#x3D;0,SF&#x3D;OF;A&lt; B ZF!&#x3D;OF<br>因为由于有符号数可能溢出时可能符号位会被扭曲。所以当OF，即溢出位为1时，符号位被扭曲，所以SF&#x3D;1（运算结果为负数），A&gt;B。</li>
</ul>
<h5 id="浮点数的表示和运算"><a href="#浮点数的表示和运算" class="headerlink" title="浮点数的表示和运算"></a>浮点数的表示和运算</h5><ul>
<li>浮点数的表示格式：<br>$$N&#x3D;(-1)^S×M×R^E$$<br>S取值0或1，表示符号；M是一个二进制的定点小数，称为尾数，一般用定点<strong>原码</strong>小数表示；E是一个二进制的定点整数，称为阶码或指码，用移码表示；R是基数(隐含)，一般约定为2，4，16<br>IEEE标准下32位和64位浮点数的格式：<table>
<thead>
<tr>
<th>符号</th>
<th>阶码</th>
<th>尾数</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>8</td>
<td>23</td>
</tr>
<tr>
<td>1</td>
<td>11</td>
<td>52</td>
</tr>
</tbody></table>
</li>
<li>浮点数的表示范围<br>上溢：大于最大正数或小于最小负数。此时统称为上溢。数据一旦上溢，计算机必须中断运算操作；<br>下溢：精度过于小时。计算机当做机器零来处理</li>
<li>浮点数的规格化<br>尾数化表示：1&#x2F;2 &lt; M&lt;1.要化简成0.1····这样的<br>IEEE754表示：再左规一次，变成1.····，然后隐含整数1</li>
<li>IEEE754标准<br>基数隐含为2.阶码的偏置值的分别为127和1023。这是为了能够表示负数的阶码<br>将实数转换成IEEE754单精度数(即32位)<br>-8.25：先转换成二进制：-1000.01&#x3D;-1.00001×2^3<br>再算阶码E：E-127&#x3D;3，E&#x3D;130&#x3D;1000 0010<br>有1；1000 0010；0000 1000 0000 0000 0000 0000&#x3D;C104 0000H<br>IEEE 全为0和全为1的特殊意义<table>
<thead>
<tr>
<th>值</th>
<th>单精度-S</th>
<th>单精度-E</th>
<th>单精度-M</th>
<th>单精度值</th>
<th>双精度-S</th>
<th>双精度-E</th>
<th>双精度-M</th>
<th>双精度值</th>
</tr>
</thead>
<tbody><tr>
<td>正零</td>
<td>0</td>
<td>00000000</td>
<td>000…0</td>
<td>+0</td>
<td>0</td>
<td>000…0 (0)</td>
<td>000…0 (0)</td>
<td>+0</td>
</tr>
<tr>
<td>负零</td>
<td>1</td>
<td>00000000</td>
<td>000…0</td>
<td>-0</td>
<td>1</td>
<td>000…0 (0)</td>
<td>000…0 (0)</td>
<td>-0</td>
</tr>
<tr>
<td>正无穷大</td>
<td>0</td>
<td>11111111</td>
<td>000…0</td>
<td>+∞</td>
<td>0</td>
<td>111…1 (1)</td>
<td>000…0 (0)</td>
<td>+∞</td>
</tr>
<tr>
<td>负无穷大</td>
<td>1</td>
<td>11111111</td>
<td>000…0</td>
<td>-∞</td>
<td>1</td>
<td>111…1 (1)</td>
<td>000…0 (0)</td>
<td>-∞</td>
</tr>
<tr>
<td>NaN</td>
<td>x (0或1)</td>
<td>11111111</td>
<td>≠0</td>
<td>NaN</td>
<td>x (0或1)</td>
<td>111…1 (1)</td>
<td>≠0</td>
<td>NaN</td>
</tr>
<tr>
<td>非规格化正数</td>
<td>0</td>
<td>00000000</td>
<td>≠0</td>
<td>正非规格化数</td>
<td>0</td>
<td>000…0 (0)</td>
<td>≠0</td>
<td>正非规格化数</td>
</tr>
<tr>
<td>非规格化负数</td>
<td>1</td>
<td>00000000</td>
<td>≠0</td>
<td>负非规格化数</td>
<td>1</td>
<td>000…0 (0)</td>
<td>≠0</td>
<td>负非规格化数</td>
</tr>
</tbody></table>
</li>
</ul>
<p><strong>尾数使用原码表示，指数使用移码表示但是偏置值不是n位移码常用的$2^{n-1}$,而是$2^{n-1}$-1</strong></p>
<ul>
<li>浮点数的加减：<ol>
<li>对阶，小阶码像大阶码看齐。右移低位移出的有效位保留并参与尾数部分的运算 </li>
<li>尾数加减，将对阶后的尾数按顶点原码小数的加减规则进行运算，记得将隐藏位还原到位数位置</li>
<li>规格化</li>
<li>舍入，像偶数舍入，正向舍入，负向舍入，截断</li>
<li>溢出判断：主要是判断指数溢出。指数上溢产生异常。指数下溢，按机器零处理。尾数溢出可以左规右规，然后判断指数有无溢出</li>
</ol>
</li>
<li>C语言中的浮点数类型：float和double分别对应IEEE754单精度浮点数和双精度浮点数。long double 对应扩展双精度浮点数。<br>不同类型数混合运算，自动类型提升运算，称为隐式类型转换<br>int-&gt; float 虽然不会溢出，但是float24位尾数，int32位，会影响精度</li>
<li>大小端和对齐储存<br>大端：先储存高位字节，再储存低位字节。字节顺序和原序列一致<br>小端：先储存低位字节，再储存高位字节。字节顺序和原序列相反<br>对齐存储：<table>
<thead>
<tr>
<th align="left">数据类型 (C&#x2F;C++)</th>
<th align="left">典型大小</th>
<th align="left">典型对齐要求</th>
<th align="left">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>char</code></td>
<td align="left">1字节</td>
<td align="left">1字节</td>
<td align="left">单个字节，可以从任何地址开始。</td>
</tr>
<tr>
<td align="left"><code>short</code></td>
<td align="left">2字节</td>
<td align="left">2字节</td>
<td align="left">起始地址必须是2的倍数（如0x1002, 0x1004）。</td>
</tr>
<tr>
<td align="left"><code>int</code></td>
<td align="left">4字节</td>
<td align="left">4字节</td>
<td align="left">起始地址必须是4的倍数（如0x1004, 0x1008）。</td>
</tr>
<tr>
<td align="left"><code>long</code></td>
<td align="left">8字节 (64位系统)</td>
<td align="left">8字节</td>
<td align="left">起始地址必须是8的倍数（如0x1008, 0x1010）。</td>
</tr>
<tr>
<td align="left"><code>float</code></td>
<td align="left">4字节</td>
<td align="left">4字节</td>
<td align="left">同<code>int</code>，地址是4的倍数。</td>
</tr>
<tr>
<td align="left"><code>double</code></td>
<td align="left">8字节</td>
<td align="left">8字节</td>
<td align="left">同<code>long</code>，地址是8的倍数。</td>
</tr>
<tr>
<td align="left">也就是说int a，char b，short c 最后是8字节</td>
<td align="left"></td>
<td align="left"></td>
<td align="left"></td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="存储系统"><a href="#存储系统" class="headerlink" title="存储系统"></a>存储系统</h3><h4 id="存储器概述"><a href="#存储器概述" class="headerlink" title="存储器概述"></a>存储器概述</h4><h5 id="存储器的分类"><a href="#存储器的分类" class="headerlink" title="存储器的分类"></a>存储器的分类</h5><ul>
<li>按在计算机的作用分类，分为主存，辅存(也称为外存)，高速缓冲存储器(Cache)<br>CPU-Cache-主存-辅存；CPU可以访问Cache和主存。辅存只能访问主存<br>主存和Cache之间的数据调动是硬件自动完成的，对程序员透明。<br>主存和辅存的数据调动是由硬件和操作系统共同完成的，对应用程序员透明</li>
<li>按储存介质分类：磁表面存储器，磁芯存储器，半导体存储器，光存储器</li>
<li>按存取方式分类：RAM(随机存储器)；只读存储器(ROM)；串行访问存储器</li>
<li>按信息的可保存性划分：断电后存储信息即消失的存储器，称为易失性存储器，如RAM；断电后信息仍然保存的存储器，称为非易失性存储器，如ROM、磁表面存储器和光存储器</li>
</ul>
<h5 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h5><ul>
<li>有三个主要性能指标：存储容量、单位成本、存储速度<br>存储容量为存储字数*字长；单位成本为总成本&#x2F;总容量；存储速度<br>存取时间T_a(启动一次存储器到完成该操作的时间)；存取周期T_m(存储器进行一次完整的读&#x2F;写操作所需的全部时间)；主存带宽B_m(数据传输速率)&#x3D;数据的宽度&#x2F;存取周期<br>存取周期往往大于存取时间，因为有恢复内部状态的时间</li>
</ul>
<h4 id="主存储器"><a href="#主存储器" class="headerlink" title="主存储器"></a>主存储器</h4><h5 id="SRAM和DRAM"><a href="#SRAM和DRAM" class="headerlink" title="SRAM和DRAM"></a>SRAM和DRAM</h5><ul>
<li>半导体存储器分为RAM和ROM。RAM又分为静态随机存储器SRAM和动态随机存储器DRAM。主存储器主要是由DRAM完成。Cache主要是有SRAM实现。都是易失性存储器</li>
<li>SRAM的工作原理<br>由双稳态触发器(六晶体管MOS)来记忆信息的；静态是指即使信息被读出后，仍保持原状态而不需要再生(非破坏性读出)<br>SRAM的存储速度快，但是功耗大、集成度低，价格昂贵，一般用于Cache</li>
<li>DRAM的工作原理<br>动态随机存储器DRAM是利用元电路中的栅极电容上的电荷来存储信息的。存储元通常只使用一个晶体管<br>相对于SRAM来说，DRAM具有集成度高，位价低，功耗小等优点。但是速度比SRAM慢。且必须定时刷新和读后再生。一般用于主存</li>
<li>SDRAM<br>DRAM电容上的电荷一般只能维持1～2ms，因此即使电源不断电，信息也会自动消失。此外，读操作会使其状态发生改变(破坏性读出)。需要读后再生。对同一行进行两次相邻刷新的时间称为刷新周期，通常取2ms。常见的刷新方式有下3种：<ol>
<li>集中刷新，在一个刷新的周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，再次期间内停止对存储器的读&#x2F;写操作。这段时间称作<strong>死时间</strong>。优点是读&#x2F;写不受刷新操作的影响。缺点是死时间内不能访问存储器</li>
</ol>
<p><code>指的是连续的一段长时间用于刷新，剩下的时间可以100%用于读写</code><br>2) 分散刷新，将一个存储器系统的工作周期分为两部分，前半部分用作正常的读写操作，后半部分用于刷新，增加了系统的存取周期。优点是没有死区。<br>3) 异步刷新：<br><code>指的是这刷新时间分散开，均匀的分布在一个系统周期内</code><br>刷新对于CPU透明。刷新不依赖于外部的访问。DRAM的刷新单位是行，由芯片内部自动生成行地址。刷新操作类似于读，根据读出的内容对相应单元进行重写。刷新和再生不完全相同。刷新是一行为单位逐行恢复数据，再生仅需恢复被读出的数据</p>
</li>
<li>DRAM的地址引脚复用技术<br>DRAM由于芯片容量较大，地址位较多，通常采用地址引脚复用技术，行地址和列地址使用相同的引脚先后两次输入，减少所需一般的地址引脚<br>如16*8位的DRAM芯片，储存阵列为4 *4，也就是需要log_2 4&#x3D;2个地址线和8个数据线。芯片内部有一个行缓冲器，用来缓存指定行中每列的数据。其大小为列数 *储存元的位数，常使用SRAM实现。选中某行后，该行所有的数据都被送到行缓冲器，以后每个时钟都可以连续的从DRAM中输出一个数据，因此支持突发传输(指在寻址阶段给出数据的首地址，在传输阶段可以传送多个连续存储单元的数据)。<br><code>作为这一行的Cache</code><br><code>总结：SRAM昂贵，使用触发器储存信息，同时送行列信息，不用刷新，用作Cache，DRAM便宜，用作主存；SDRAM更加先进，是同步DRAM芯片</code></li>
</ul>
<h5 id="ROM-只读存储器"><a href="#ROM-只读存储器" class="headerlink" title="ROM(只读存储器)"></a>ROM(只读存储器)</h5><ul>
<li>ROM的特点：<br>ROM和RAM都是支持随机访问的存储器，SRAM和DRAM都是易失性存储器(依赖于长时稳定的电源供应)而ROM掉电也不会丢失信息。</li>
<li>ROM类型：分为掩模式只读存储器MROM、一次可编程只读存储器PROM、可擦除可编程只读存储器、Flash存储器和固态硬盘SSD<br>掩模式只读存储器：半导体厂商按要求在芯片制作中直接写入，任何人无法更改内容，价格便宜<br>一次可编程只读存储器：允许用户利用专门的设备写入自己的程序，一旦写入无法更改<br>可擦除可编程只读存储器：可以改写，但是编程次数有限且慢，所以替代不了RAM<br>Flash存储器：在EPROM（(可擦除可编程只读存储器)发展而来，兼顾ROM和RAM优点，U盘是一种Flash(NAND Flash)<br>固态硬盘：基于闪存的固态硬盘室友固态电子储存芯片阵列制成的硬盘，有控制单元和储存单元(Flash)组成。</li>
</ul>
<h5 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h5><ul>
<li>CPU首先把被访问单元的地址送到MAR中，通过地址线将主存地址送到主存中的地址寄存器，以便地址译码器进行译码。选中相应的单元，同时CPU将读写控制信号送到主存的读写控制电路。若是写操作，则CPU同事讲要写的内容送到MDR，在读写控制电路的控制下，经数据线将信号写入选中的单元 ；若是都操作则主存读出选中单元的内容送纸数据线，然后被送到MDR</li>
<li>MDR的位数和数据线的位数相同。MAR的位数和地址线的位数相同。</li>
</ul>
<h5 id="多模块存储器"><a href="#多模块存储器" class="headerlink" title="多模块存储器"></a>多模块存储器</h5><p>多模块存储器是一种空间并行技术，利用多个结构完全相同的存储模块的并行工作来提高存储器的吞吐率；常见的有单体多字存储器和多体低位交叉存储器</p>
<ul>
<li>单体多字存储器：在该存储器，每个存储单元存储m个字，总线宽度也为m个字；一次并行读取m个字，在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每个1&#x2F;m个存取周期，CPU向主存取一条指令;但是一旦遇到转移指令或是操作数不能连续存放时，这种方式的提升就不明显</li>
<li>多体并行储存器：<ul>
<li>高位交叉编址：高位表示模块号，每个模块都有相同的容量和存取速度，各模块都有独立的读写控制电路。低位地址为模块内地址。访问一个连续主存块中，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，CPU总是按顺序访问存储模块，因此不能提高存储器的吞吐率</li>
<li>低位交叉编址：每个模块按”模m”交叉编址，模块号&#x3D;单元地址%m。该方式可以采用轮流启动和同时启动两种方式。<br>轮流启动方式：若每个模块一次读写的位数正好等于数据总线位数，模块的存取周期为T，总线周期为r。按每隔1&#x2F;m个存取周期轮流启动各模块，则每个1&#x2F;m个存储周期就可以读出或写入一个数据。存取速度提高m倍。交叉存储器要求其模块数大于或等于m，保证某模块在m*r时间后可再次启动该模块。这样连存储m个字所需T&#x3D;(m-1)r；；；但是如果相邻m次请求中有多个访问地址在同一个模块中，会出现访存冲突，需要延迟发生冲突的访问请求<br>同时启动方式：如果有4个模块，每个模块一次读取的位数是16位。数据总线是64位。因此应该同时启动4个模块进行并行读写</li>
</ul>
</li>
</ul>
<h4 id="主存储器和CPU的链接"><a href="#主存储器和CPU的链接" class="headerlink" title="主存储器和CPU的链接"></a>主存储器和CPU的链接</h4><ul>
<li>连接原理：主存储器通过数据总线，地址总线和控制总线与CPU链接；数据总线的位数与工作频率的乘积正比与数据传输速率；地址总线的位数决定了可寻址的最大内存空间；控制总线指出总线周期的类型和本次输入输出操作完成的时刻。<br>单个芯片的熔炼是有限的，因此通过存储器芯片扩展技术，将多个芯片集成在一个内存条上，然后由多个内存条以及主板上的ROM芯片组成计算机作序的主存空间，再通过总线和CPU相连</li>
</ul>
<h5 id="主存容量的扩展"><a href="#主存容量的扩展" class="headerlink" title="主存容量的扩展"></a>主存容量的扩展</h5><ul>
<li>位扩展法：指对字长进行扩展。当CPU的系统数据线多于储存芯片的数据位数时，必须对储存芯片进行扩位。使其数据位数和CPU的数据线数相等。8片8K×1位的芯片组成8K×8位的芯片<br>位扩展的连接方法：各芯片的地址线、片选控制线和读写控制线与系统总线相应并联。各芯片的数据线单独引出，分别连接系统数据线。各芯片同时工作</li>
<li>字扩展法：<br>对储存字的数量进行扩展。各芯片的地址线和系统地址线的低位对应项链，芯片的数据线和读写控制线与系统总线相应并联。由系统的高位译码得到各芯片的片选信号。各芯片分时工作<br>例如4片16K×8位的RAM芯片组成64K×8位的储存器。<br>00开头表示第一片芯片</li>
<li>一般来说都是运行字位同时扩展法</li>
</ul>
<h5 id="储存芯片的地址分配和片选"><a href="#储存芯片的地址分配和片选" class="headerlink" title="储存芯片的地址分配和片选"></a>储存芯片的地址分配和片选</h5><h5 id="储存器和CPU的链接"><a href="#储存器和CPU的链接" class="headerlink" title="储存器和CPU的链接"></a>储存器和CPU的链接</h5><ul>
<li>一般来说，使用ROM存放系统程序、标准子程序和各类常数；RAM则是为用户编程而设置的</li>
<li>一般来说CPU的地址线要比存储芯片的地址线多，所以存储芯片的地址线一般连接到CPU的低位地址线</li>
<li>CPU的数据线一定要和储存芯片的地址线一样多，如果不一样要对储存芯片进行字位扩展</li>
<li>读写如果连在一下，高水平为读，低水平为写。但是如果分开作为RD和WE，均为低水平有效</li>
</ul>
<h4 id="外部存储器"><a href="#外部存储器" class="headerlink" title="外部存储器"></a>外部存储器</h4><h5 id="磁盘存储器"><a href="#磁盘存储器" class="headerlink" title="磁盘存储器"></a>磁盘存储器</h5><ul>
<li>磁盘存储器由磁盘驱动和磁盘控制器组成。磁盘驱动器是驱动磁盘转动并在盘面上进行读写操作的装置；磁盘控制器是磁盘驱动器与主机的接口，负责接收并解释CPU发来的命令。</li>
<li>储存区域：一个磁盘分为若干记录面，每个记录面又分为若干圆形的磁道，每条磁道又划分为若干扇区，扇区(也称块)是磁盘读写的最小单位<ul>
<li>磁头数：即记录面数，一个记录面对应一个磁头</li>
<li>柱面数：表示磁盘每面盘面上有多少条磁道，在一个盘组中，不同记录面的相同位置的磁道构成一个圆柱面</li>
<li>扇区数：表示每条磁道上有多少个扇区</li>
</ul>
</li>
</ul>
<p><code>磁盘是以柱面为单位连续存储的，这样磁头臂不用去寻道，只需要不断切换不同的磁头即可，在一个柱面的存储空间全部用完后才会去下一个柱面</code></p>
<ul>
<li>磁盘高速缓存：在内存中开辟一部分区域用于缓冲将要被送到磁盘上的数据。主要是磁盘的读写对于内存太慢了，整个系统都在等磁盘的工作，所以开辟一个缓存空间，延迟写入。写磁盘是按”簇”(多个盘区统一叫做一个簇，方便管理)写的，会尽量分配到同一个柱面的连续簇中。</li>
<li>磁盘的性能指标：<ul>
<li>记录密度：盘片单位面积上记录的二进制数据量，通常以道密度(沿磁盘半径方向单位长度上的磁道数)、位密度(磁道单位长度上能记录的二进制代码位数)、面密度(位密度和道密度的乘积)表示</li>
<li>磁盘的容量：非格式化：记录面数×柱面数×每条磁道的磁化单元数；格式化：记录面数×柱面数×每道扇区数×每个扇区的容量</li>
<li>存取时间：由寻道时间(磁头移动到目的磁道的时间)、旋转延迟时间(磁头定位到要读写的扇区的时间)、传输时间(传输数据所花费的时间)三部分构成。</li>
<li>数据传输速率：磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输速率。假设磁盘转数位r转&#x2F;秒，每条磁道容量为N字节，则数据传输速率D_r&#x3D;rN。</li>
</ul>
</li>
<li>磁盘地址：磁盘的地址一般如下<table>
<thead>
<tr>
<th>柱面(磁道)号</th>
<th>盘面(磁头)号</th>
<th>扇区号</th>
</tr>
</thead>
<tbody><tr>
<td>如果有16个盘面，每个盘面有256个磁道，每个磁道划分为16个扇区。则有8位的柱面号，4位的盘面号和4位的扇区号</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<ul>
<li>磁盘的主要操作为：寻址、读盘，写盘。第一步是读取控制字，第二步是执行控制字。磁盘读写是串行的</li>
</ul>
</li>
<li>磁盘阵列：RAID(独立冗余磁盘阵列)指将多个独立的物理磁盘组成一个独立的逻辑盘。数据在多个物理盘中分个交叉存储，并行访问。具有更好的存储性能和安全性<ul>
<li>RAID0：无冗余无校验：连续多个数据块交替放在不同的物理磁盘的扇区中。几个磁盘交叉进行并行读写</li>
<li>RAID1：镜像磁盘阵列:两个磁盘同时读写，互为备份</li>
<li>RAID2：纠错的海明码</li>
<li>RAID3:位交叉奇偶校验</li>
<li>RAID4：块交差奇偶校验</li>
<li>RAID5：无独立校验的奇偶校验</li>
</ul>
</li>
</ul>
<h5 id="固态硬盘"><a href="#固态硬盘" class="headerlink" title="固态硬盘"></a>固态硬盘</h5><p>SSD是基于闪存的储存器，和U盘没有本质区别，只是容量更大，存取性能更好。一个SSD由一个或多个闪存芯片和闪存翻译层组成。闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号，相当于替代了磁盘控制器的角色</p>
<ul>
<li>磨损均衡：闪存的擦写寿命是有限的，一般是几百次到几千次。如果集中使用一部分闪存，这部分会磨损的特别快，导致整一块SSD也损坏<br>由此引入磨损均衡：动态磨损均衡：优先选取擦除次数少的新闪存块。静态磨损均衡(更先进)：就算没有数据写入，SSD也会检测并自动进行数据分配，让老闪存块承担以读为主的存储任务。</li>
</ul>
<h4 id="高速缓冲存储器"><a href="#高速缓冲存储器" class="headerlink" title="高速缓冲存储器"></a>高速缓冲存储器</h4><p>Cache通常集成在CPU当中</p>
<ul>
<li>时间局部性：最近的未来要是用的信息，很可能是现在正在使用的信息。空间局部性：最近的未来要用到的东西很可能与现在正在使用的信息在存储空间上是临近的。</li>
<li>分析指定代码的时空局部性：主要还是看被经常调用的数据是怎样分布的</li>
</ul>
<h5 id="Cache的基本工作原理"><a href="#Cache的基本工作原理" class="headerlink" title="Cache的基本工作原理"></a>Cache的基本工作原理</h5><p>便于Cache和主存交换信息，Cache和主存都被划分为大小相等的块，Cache块也称作Cache行。每块有若干字节组成。块的长度称作块长，也称作行长。Cache块数远小于主存中的块数。</p>
<ul>
<li>CPU 发出读请求时，先访问寄存器，当寄存器没有时，访问Cache(包含L1(每个CPU核心自己一个)，L2，L3(多个核心公用))。当Cache命中时，将地址转化为Cache地址，直接对Cache进行读操作，和主存无关。当不命中时候，访问主存，并把刚刚访问的这个块替换成Cache中的某一块。上述全程硬件实现。CPU和Cache交换以字为单位，但是Cache和主存交换以Cache块为单位</li>
<li>CPU发出写操作时，若Cache命中，有可能遇到Cache和主存内容不一的情况，需要一定的写策略</li>
<li>Cache命中率：访问Cache的次数与访问Cache的次数和访问主存的次数的和的比值</li>
</ul>
<h5 id="Cache和主存的映射方式"><a href="#Cache和主存的映射方式" class="headerlink" title="Cache和主存的映射方式"></a>Cache和主存的映射方式</h5><p>Cache腰围每块加一个标记位，指明它是主存的哪一块。标记的内容相当于内存中块的编号。为了说明Cache中信息是否有效，还要加一位有效位</p>
<ul>
<li>直接映射：内存中的每一块都只能装进Cache的唯一位置。若这个位置一有内容，则产生块冲突。原来的块必须无条件替换出去。实现简单，但是不够灵活。方法是Cache行号&#x3D;主存块号%Cache行数。如果Cache有2^c块，主存有2^m块。则Cache中的低c位行号就是主存中的低c位行号。而主存的高位则是有m-c个作为标记位。最后接b位来标识块内地址<br>访存流程是首先根据访存地址中间c位来找对应的Cache行，将Cache行中的标记和对应的主存地址的高t位标记进行比较，若相等(为了判断是不是同一个主存的地址)且有效位是1，则访问命中，根据主存地址低位的块内地址。<code>我要访问一个主存，我现在是有一个主存地址。然后根据主存地址中间的c位来判断Cache标志位和高位是不是一样的。如果一样的话，我就根据主存地址中的块内地址来访问Cache块内地址来读</code></li>
<li>全相联映射：主存中的每一块可以装入Cache中的任意位置。但是标记的比较速度慢加成本高<br>地址结构是|标记|块内地址|；首先将主存的高位标记(位数&#x3D;log2主存块数)与Cache各行的标记进行比较，若有一个相等缺有效位为1，则命中。不命中则将该地址所在这一块信息宋奥Cache任意空闲行，有效位置1，设置标记。</li>
<li>组相联映射：将Cache分成Q个大小相等的组，每个主存块可以装入固定组中的任意一行。即组间采用直接映射，组内采用全相联映射。每组有几行Cache就是几路组相联。组相联映射关系：Cache组号&#x3D;主存块号%组数Q；|标记|组号|块内地址|<br>访存流程为：首先根据中间的组号找到对应的Cache组。将对应Cache组的标记和主存地址的高位地址做比较。如果相等且有效则访问Cache命中</li>
</ul>
<h5 id="Cache中主存块的替换算法"><a href="#Cache中主存块的替换算法" class="headerlink" title="Cache中主存块的替换算法"></a>Cache中主存块的替换算法</h5><ul>
<li>随机算法：随机的替换</li>
<li>先进先出：选择最早调入的Cache进行替换</li>
<li>LRU(近期最少使用)算法：对每个Cache设置一个计数位，也称LRU替换位。记录主存块的使用情况。假如4路组相联<ol>
<li>命中时所命中的计数器清零，比其低的计数器加一。</li>
<li>未命中且还有空闲行时，新装入的行计数器置0，其余非空闲行全+1</li>
<li>未命中且无空闲行，计数值为n-1&#x3D;3的行被替换，新装入的行计数器为0，其余的全+1<br>当集中访问的存储器大于Cache，就会不停的调换，称为抖动</li>
</ol>
</li>
<li>最不经常使用算法：将一段时间内被访问次数最少的Cache换出。每行也设置一个计数器，新行装入后从零开始计数，每访问一次，计数器+1；替换时将最小的行数换出。</li>
</ul>
<h5 id="Cache的一致性问题"><a href="#Cache的一致性问题" class="headerlink" title="Cache的一致性问题"></a>Cache的一致性问题</h5><ul>
<li>写命中策略：<ul>
<li>直写法：有修改直接写会内存。耗时但是一致；写缓冲：为了减少全写法直接写入主存的时间损耗，在Cache和主存之间加入一个写缓冲。</li>
<li>回写法：有修改不写回内存，而是表示脏位(表示有修改)，只有当因为内存不足被移出Cache时才会写回内存。快，但是有一段时间最新和内存不一致</li>
</ul>
</li>
<li>写不命中策略<ul>
<li>写分配法：没有写命中时，更新主存单元，然后把这个主存块调入Cache。</li>
<li>非写分配法：只更新主存单元而不调入Cache</li>
</ul>
</li>
<li>非写分配法常常和全写法(直写法)搭配(追求稳定性)。写分配法常和回写法分配(追求速度)</li>
<li>分级式Cache：由于执行部件存取数据时，指令预取部件要从同一Cache读指令，可能会引发冲突。所以采用分离式Cache<br>L1离CPU更近，速度更快，容量更小。<br>一个两级Cache系统，L1Cache对L2Cache使用全写法，L2Cache对主存使用回写法。由于L2的存在，其访问速度远大于主存，避免了频繁写是造成的写缓冲饱和溢出<br><code>由于L1 Cache对L2 Cache使用直写法，每次CPU写L1时都会触发对L2的写操作，从而导致L2接收频繁的写请求。如果L2 Cache也对主存使用直写法，那么这些频繁的写操作会直接传递到主存，而主存访问速度较慢，容易导致写缓冲（Write Buffer）饱和或溢出，从而成为性能瓶颈。但在这个系统中，L2 Cache对主存使用回写法，因此L2会先将写操作累积在缓存中（标记为“脏”），只在必要时（如缓存行替换时）才写回主存。这样，L2 Cache acts as a buffer，减少了直接写主存的频率，避免了写缓冲饱和问题。</code></li>
</ul>
<h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><h1 id="高等数学"><a href="#高等数学" class="headerlink" title="高等数学"></a>高等数学</h1><h2 id="函数极限与连续"><a href="#函数极限与连续" class="headerlink" title="函数极限与连续"></a>函数极限与连续</h2><h3 id="常用极限"><a href="#常用极限" class="headerlink" title="常用极限"></a>常用极限</h3><p>$$ \lim_{x\rightarrow0}{e^x-1}  &#x3D; x$$<br>$$ \lim_{x\rightarrow0}{(1+x)^n-1}  &#x3D; x$$<br>$$ \lim_{x\rightarrow0}{1-\cos x}  &#x3D; \frac12x^2$$<br>$$ \lim_{x\rightarrow0}{ln(x+1)}  &#x3D; x$$<br>$$ \lim_{x\rightarrow0}{x-ln(1+x)&#x3D;\frac12x^2}$$<br>$$ \lim_{x\rightarrow0}{e^x-1}  &#x3D; x$$<br><code>yssy,泰勒公式还是太权威了,上述的可以用泰勒公式很快的推导出来,但是一些加减的还是需要泰勒公式</code></p>
<h3 id="泰勒公式-在0处"><a href="#泰勒公式-在0处" class="headerlink" title="泰勒公式(在0处)"></a>泰勒公式(在0处)</h3><p>$$f(x)&#x3D;f(0)+f’(0)x+\frac{f’’(0)}{2!}x^2+\frac{f’’’(0)}{3!}x^3+o(x^3)$$</p>
<h3 id="题目总结"><a href="#题目总结" class="headerlink" title="题目总结"></a>题目总结</h3><ul>
<li>判断$x\rightarrow\infty 时要确认正负无穷的情况,若正负无穷不相等,则不存在$</li>
<li>$2^t-3^t &#x3D; 3^t((\frac{2}{3})^t-1)&#x3D;3^ttln\frac23$</li>
<li>求$f(x)^{g(x)}可以变换成g(x)lnf(x)在换成g(x)ln{((f(x)-1)+1)}$在f(x)-1趋于0时,有g(x)(f(x)-1)&#x3D;lny<br><code>最后记得y要变成e^&#123;g(x)(f(x)-1)&#125;</code></li>
<li>遇到$\sqrt{1+\tan x}±\sqrt{1+\sin x}$这样形式的,考虑$\frac{(1+\tan x)-(1+\sin x)}{\sqrt{1+\tan x}±\sqrt{1+\sin x}}$,即平方差公式</li>
<li>求$\lim_{x\rightarrow\infty}ln(1+2^x)$看着很像ln(1+x)&#x3D;x但是这个前提是x趋于0,于是$ln(1+2^x)$可以化简成$ln(2^x(2^{-x+1}))$即$xln2+2^{-x}$后者趋于0,原式&#x3D;$xln2$。<del>也算是ln(1+x)的变种吧</del></li>
<li>另一个和上面相似的题目:$\lim_{x\rightarrow0}(\cos x+\sin x)^{\frac{1}{2x}}$化简成:$\frac{1}{2t}ln(cosx+sinx)$到这里变成$\frac{ln(cosx+sinx)}{2t}$然后洛必达可得最后结果</li>
<li>求多次泰勒多项式:求出各个函数对应到某一个级别的泰勒多项式相乘,取对应的o(x)即可</li>
<li>arcsinx 泰勒公式:$x+\frac{x^3}{6}+o(x^3)$</li>
</ul>
<h3 id="间断点"><a href="#间断点" class="headerlink" title="间断点"></a>间断点</h3><p>是无定义的点</p>
<ul>
<li>第一类间断点也叫有限型间断点，其特点是左右极限均存在.<ul>
<li>可去间断点:左极限，右极限存在且相等</li>
<li>跳跃间断点:左极限和右极限均存在，但不相等。</li>
</ul>
</li>
<li>第二类间断点左右极限至少有一个不存在。注：除了第一类间断点其余均为第二类间断点<ul>
<li>无穷间断点:在该点可以无定义，且左右极限至少有一个不存在，且改函数在该点极限为∞。</li>
<li>震荡间断点:在该点可以无定义，当自变量趋于该点时，函数值再两个常数之间变动无限多次。此时左右极限均不存在。</li>
</ul>
</li>
</ul>
<h2 id="数列极限"><a href="#数列极限" class="headerlink" title="数列极限"></a>数列极限</h2><p><code>考虑洛必达,日了,张宇第一题居然是硬洛必达</code></p>
<ul>
<li>$\sqrt[n]{a^n+b^n}&#x3D;max(a,b)$</li>
<li>有大于小于可以考虑夹逼准则</li>
</ul>
<h3 id="微分中值定理"><a href="#微分中值定理" class="headerlink" title="微分中值定理"></a>微分中值定理</h3><ul>
<li>有一道经典例题</li>
</ul>
<p>给定数列 $x_n$ 满足递推关系 $x_{n+1} &#x3D; f(x_n)$，其中函数 $f$ 可导，且存在唯一的 $a$ 满足 $f(a) &#x3D; a$，同时对任意 $x$，有 $|f’(x)| \leq k &lt; 1$。需要证明序列 $x_n$ 收敛于 $a$。</p>
<h4 id="证明："><a href="#证明：" class="headerlink" title="证明："></a>证明：</h4><p>设 $e_n &#x3D; x_n - a$ 表示第 $n$ 项与不动点 $a$ 的误差。由于 $a$ 是 $f$ 的不动点，即 $f(a) &#x3D; a$，有：<br>$x_{n+1} &#x3D; f(x_n), \quad x_{n+1} - a &#x3D; f(x_n) - f(a).$<br><strong>由微分中值定理</strong>，在 $x_n$ 与 $a$ 之间存在一点 $c_n$ 使得：<br>$f(x_n) - f(a) &#x3D; f’(c_n)(x_n - a).$<br>因此：<br>$x_{n+1} - a &#x3D; f’(c_n)(x_n - a).$<br>取绝对值并利用条件 $|f’(x)| \leq k &lt; 1$：<br>$|x_{n+1} - a| &#x3D; |f’(c_n)| \cdot |x_n - a| \leq k |x_n - a|.$<br>即：<br>$|e_{n+1}| \leq k |e_n|.$<br><strong>迭代上述不等式：</strong><br>$|e_n| \leq k |e_{n-1}| \leq k^2 |e_{n-2}| \leq \cdots \leq k^n |e_0|.$<br>其中 $e_0 &#x3D; x_0 - a$。由于 $k &lt; 1$，有 $\lim_{n \to \infty} k^n &#x3D; 0$，因此：<br>$\lim_{n \to \infty} |e_n| &#x3D; 0,$<br>即 $\lim_{n \to \infty} x_n &#x3D; a$。<br>综上，序列 $x_n$ 收敛于唯一不动点 $a$。<br>$<br>\boxed{\text{序列 } x_n \text{ 收敛于 } a}<br>$</p>
<h2 id="积分微分"><a href="#积分微分" class="headerlink" title="积分微分"></a>积分微分</h2><ul>
<li>$tanx’&#x3D;sec^2x$</li>
</ul>
<h3 id="一、基本积分"><a href="#一、基本积分" class="headerlink" title="一、基本积分"></a>一、基本积分</h3><ol>
<li>幂函数<br>$$\int x^n  dx &#x3D; \frac{x^{n+1}}{n+1} + C \quad (n \neq -1)$$</li>
<li>分式<br>$$\int \frac{1}{x}  dx &#x3D; \ln|x| + C$$</li>
<li>指数函数<br>$$\int e^x  dx &#x3D; e^x + C$$<br>$$\int a^x  dx &#x3D; \frac{a^x}{\ln a} + C \quad (a&gt;0, a\neq1)$$</li>
<li>三角函数<br>$$\int \sin x  dx &#x3D; -\cos x + C$$<br>$$\int \cos x  dx &#x3D; \sin x + C$$</li>
</ol>
<h3 id="二、正切与余切积分"><a href="#二、正切与余切积分" class="headerlink" title="二、正切与余切积分"></a>二、正切与余切积分</h3><ol start="5">
<li><strong>正切函数</strong><br>$$\int \tan x  dx &#x3D; -\ln|\cos x| + C &#x3D; \ln|\sec x| + C$$</li>
<li>余切函数<br>$$\int \cot x  dx &#x3D; \ln|\sin x| + C &#x3D; -\ln|\csc x| + C$$</li>
<li>正割相关<br>$$\int \sec x  dx &#x3D; \ln|\sec x + \tan x| + C$$<br>$$\int \sec^2 x  dx &#x3D; \tan x + C$$<br>$$\int \sec x \tan x  dx &#x3D; \sec x + C$$</li>
<li>余割相关<br>$$\int \csc x  dx &#x3D; -\ln|\csc x + \cot x| + C$$<br>$$\int \csc^2 x  dx &#x3D; -\cot x + C$$<br>$$\int \csc x \cot x  dx &#x3D; -\csc x + C$$</li>
</ol>
<h3 id="三、平方形式积分"><a href="#三、平方形式积分" class="headerlink" title="三、平方形式积分"></a>三、平方形式积分</h3><ol start="9">
<li><strong>平方差形式</strong><br>$$\int \frac{1}{a^2 - x^2}  dx &#x3D; \frac{1}{2a} \ln \left| \frac{a+x}{a-x} \right| + C \quad (|x|&lt;|a|)$$<br>$$\int \frac{1}{1 - x^2}  dx &#x3D; \frac{1}{2} \ln \left| \frac{1+x}{1-x} \right| + C &#x3D; \tanh^{-1} x + C$$</li>
<li>平方和形式<br>$$\int \frac{1}{a^2 + x^2}  dx &#x3D; \frac{1}{a} \arctan\frac{x}{a} + C$$</li>
<li>平方根形式<br>$$\int \frac{1}{\sqrt{a^2 - x^2}}  dx &#x3D; \arcsin\frac{x}{a} + C \quad (|x|&lt;|a|)$$<br>$$\int \frac{1}{\sqrt{a^2 + x^2}}  dx &#x3D; \ln \left| x + \sqrt{x^2 + a^2} \right| + C$$</li>
</ol>
<h3 id="四、其他重要积分"><a href="#四、其他重要积分" class="headerlink" title="四、其他重要积分"></a>四、其他重要积分</h3><ol start="12">
<li>二次根式<br>$$\int \sqrt{a^2 - x^2}  dx &#x3D; \frac{x}{2} \sqrt{a^2 - x^2} + \frac{a^2}{2} \arcsin\frac{x}{a} + C$$<br>$$\int \sqrt{x^2 \pm a^2}  dx &#x3D; \frac{x}{2} \sqrt{x^2 \pm a^2} \pm \frac{a^2}{2} \ln \left| x + \sqrt{x^2 \pm a^2} \right| + C$$</li>
<li>分式分解<br>$$\int \frac{1}{x^2 - a^2}  dx &#x3D; \frac{1}{2a} \ln \left| \frac{x-a}{x+a} \right| + C \quad (|x|&gt;|a|)$$<br>$$\int \frac{1}{(x-a)^n}  dx &#x3D; -\frac{1}{(n-1)(x-a)^{n-1}} + C \quad (n \neq 1)$$</li>
</ol>
<h3 id="五、其他重要公式"><a href="#五、其他重要公式" class="headerlink" title="五、其他重要公式"></a>五、其他重要公式</h3><ol start="14">
<li>$\arctan a -\arctan b &#x3D;\arctan{\frac{a-b}{1+ab}}$</li>
<li>sin(A+B)&#x3D;sinAcosB+cosAsinB,sin(A-B)&#x3D;sinAcosB-cosAsinB</li>
<li>2sinAcosB&#x3D;sin(A+B)+sin(A-B)</li>
<li>万能代换:$t&#x3D;tan\frac{x}{2},sinx&#x3D;\frac{2t}{1+t^2},cosx&#x3D;\frac{1-t^2}{1+t^2}dx&#x3D;\frac{2}{1+t^2}$</li>
</ol>
<h2 id="一元函数微分学"><a href="#一元函数微分学" class="headerlink" title="一元函数微分学"></a>一元函数微分学</h2><ul>
<li>导数的定义：$\frac{f(x-\Delta)-f(x)}{\Delta}$</li>
<li>偏导数:隐函数(由$y&#x3D;xy+y^3$类似得到的y&#x3D;f(x)),有化成$F(x)&#x3D;xy-y+y^3$,然后$$y’&#x3D;-\frac{F_x’}{F_y’}$$</li>
<li>其实隐函数还有一个常用解法:两边对x求导,</li>
</ul>
<p><code>当让你求具体某一个点的一阶导数二阶导数时,往往是这个两边求x导更加快捷</code></p>
<h3 id="一元函数微分学-几何应用"><a href="#一元函数微分学-几何应用" class="headerlink" title="一元函数微分学-几何应用"></a>一元函数微分学-几何应用</h3><ul>
<li>注意题目中说的是”*极值点&lt;0”*还是”<em>极值&lt;0</em>“</li>
<li>$xlnx$在x趋于1时趋于0,可以把$xlnx$化成$\frac{lnx}{\frac1x}$后洛必达解决</li>
<li><strong>拐点</strong>:指f’’(x)在该点两边变号,即使该点<strong>无定义&#x2F;不存在</strong>,也是拐点</li>
<li><strong>曲率</strong>$$k&#x3D;\frac{|y’’|}{(1+y’^2)^{\frac32}}$$或者x,y以t表示时$$k&#x3D;\frac{|x’y’’-y’x’’|}{(x’^2+y’^2)^{\frac32}}$$</li>
<li>曲率圆半径是曲率的倒数</li>
<li>曲率中心的计算为:<br> $对于(x_0,y_0),有x&#x3D;x_0-\frac{y’(1-y’^2)}{y’’},y&#x3D;y_0+\frac{(1-y’^2)}{y’’}$</li>
<li>如果有曲率圆方程,说曲率圆方程在这一点上和f(x)近似,可以求泰勒近似$f(x_0)&#x3D;f(x_0)+\frac{f’(x_0)}{1!}(x-x_0)+\frac{f’’(x_0)}{2!}(x-x_0)^2+o(x^2)$</li>
<li>斜渐近线:若有y&#x3D;ax+b,$a&#x3D;\lim_{x\rightarrow\infty}\frac{f(x)}{x},b&#x3D;\lim_{x\rightarrow\infty}f(x)-ax$,看平行渐近线有:$\lim_{x\rightarrow\infty}f(x)$</li>
</ul>
<h3 id="一元函数微分学-中值定理，微分等式与不等式"><a href="#一元函数微分学-中值定理，微分等式与不等式" class="headerlink" title="一元函数微分学-中值定理，微分等式与不等式"></a>一元函数微分学-中值定理，微分等式与不等式</h3><ul>
<li><strong>拉格朗日中值定理</strong>：$f(a)-f(b)&#x3D;f’(\xi)(a-b)$</li>
<li>$\lim_{x\rightarrow0}(1+x)^b&#x3D;1+bx$(原理是二项式展开)</li>
<li>遇到没说连续可导但是有导数时考虑导数的定义</li>
<li><strong>拉格朗日余项</strong>:$o(x^n)$换成$R_n(x) &#x3D; \frac{f^{(n+1)}(\xi)}{(n+1)!} (x - a)^{n+1}$</li>
<li>当$f’’’(x)&#x3D;0$无实根,则$f’’(x)$最多有1个实根;$f’(x)$最多有2个实根;$f(x)$最多有个3实根,具体有没有可以赋值看x在具体值时f(x)的大于小于</li>
<li>有没有实根,是不是至少有一个实根,考虑<strong>罗尔定理</strong>:如果 R 上的函数f(x)满足以下条件：（1）在闭区间[a,b]上连续，（2）在开区间(a,b)内可导，（3）f(a)&#x3D;f(b)，则至少存在一个ξ∈(a,b)，使得f’(ξ)&#x3D;0。构造f(x)&#x3D;f’(ξ)。</li>
<li><strong>柯西中值定理</strong>：设函数 $f(x)$ 和 $g(x)$ 满足以下条件：  闭区间连续,开区间可导,分母导数非零：对任意 $x \in (a, b)$，有 $g’(x) \neq 0$；</li>
</ul>
<p>则在开区间 $(a, b)$ 内<strong>至少存在一点 $\xi$</strong>，使得：<br>$$<br>\frac{f’(\xi)}{g’(\xi)} &#x3D; \frac{f(b) - f(a)}{g(b) - g(a)}<br>$$<br>或等价写成：<br>$$<br>\left[ f(b) - f(a) \right] g’(\xi) &#x3D; \left[ g(b) - g(a) \right] f’(\xi)<br>$$</p>
<h3 id="一元函数微分学-物理应用"><a href="#一元函数微分学-物理应用" class="headerlink" title="一元函数微分学-物理应用"></a>一元函数微分学-物理应用</h3><ul>
<li>求变化率：一般是函数两边对t求导，化成两个变量对t求导的关系，已知其中之一，另外一个带入数值可解</li>
</ul>
<h2 id="一元函数积分学"><a href="#一元函数积分学" class="headerlink" title="一元函数积分学"></a>一元函数积分学</h2><h3 id="一元函数积分学的概念和性质"><a href="#一元函数积分学的概念和性质" class="headerlink" title="一元函数积分学的概念和性质"></a>一元函数积分学的概念和性质</h3><ul>
<li>积分定义：让你求$lim_{n\rightarrow\infty}\sum_{k&#x3D;1}^n{f(k,n)}$要化简成$\frac{k}{n}$,这个就是x在(0,1)上的微分.代换可解</li>
<li>要和1比较积分大小时,若原式是$\frac{a}{b}$可以考虑a-b和0的关系</li>
<li>反函数的导数是原函数导数分之一</li>
<li>复合函数只有外奇内奇整体才是奇函数</li>
<li>函数是否发散:$\int_{-\infty}^{+\infty}f(x)$是否发散:$\int_{-\infty}^{0}f(x)$和$\int_{0}^{+\infty}f(x)$是否等与0</li>
<li>函数发散也可以通过比较判断:$\int_{-\infty}^{+\infty}e^{-x}$收敛,$e^{-x}$&gt;$e^{-x^2}$,$\int_{-\infty}^{+\infty}e^{-x^2}$也收敛</li>
<li>$\int_{0}^{1}\frac{x}{ln^2(1+x)}$和$\int_{0}^{1}\frac{x}{x^2}$和$\int_{0}^{1}\frac{1}{x}$同敛散</li>
</ul>
<h3 id="一元函数积分学的计算"><a href="#一元函数积分学的计算" class="headerlink" title="一元函数积分学的计算"></a>一元函数积分学的计算</h3><ul>
<li>对于$\frac{1}{(t-1)(t+1)^2}$的化简.有原式&#x3D;$\frac{A}{(t-1)}+\frac{B}{(t+1)}+\frac{C}{(t+1)^2}$</li>
<li><strong>变上限积分</strong>：$\int_{-x}^xf(t+x)dt$不能直接把t换成x带入,要令$u&#x3D;t+x$上式变成$\int_0^{2x}f(u)du$,他的导数就是$2f(2x)$</li>
<li>$\int^{x-y}e^tdt$<strong>对x求偏导</strong>是$e^{x-y}$但是<strong>对于y求偏导</strong>是$-e^{x-y}$</li>
<li>判断积分也好导数也好函数也好是否连续,通过定义$$\frac{f(\Delta)-f(x)}{\Delta-x}$$和在该点的导数来判断在该点是否相等</li>
<li>切记$\sqrt{x^2}&#x3D;|x|$</li>
<li>求积分时,考虑积分上下限对于被积函数的影响.有可能需要截断上下限变成两个函数求积分</li>
<li>有$F(x)&#x3D;\int_2^xf(x)$,就有隐含条件:$F(2)&#x3D;0$</li>
<li>$(\sqrt{x^2-1}-x)^2&#x3D;\frac{1}{(\sqrt{x^2-1}+1)^2}$</li>
<li>常用变换:令t&#x3D;1&#x2F;x</li>
<li>$(arcsinx)’&#x3D;\frac{q}{\sqrt{1-x^2}}$,$(arccosx)’&#x3D;-\frac{q}{\sqrt{1-x^2}}$</li>
</ul>
<h2 id="多元函数微分学"><a href="#多元函数微分学" class="headerlink" title="多元函数微分学"></a>多元函数微分学</h2><ul>
<li><p><strong>方向导数</strong><br>设函数$f(x,y)$在点$P_0(x_0,y_0)$初可微,则函数$f(x,y)$在点$P_0$处沿任⼀⽅向L的⽅向导数都存在，方向导数为</p>
<p>$\frac{\partial f}{\partial x}(x_0,y_0) \cos \alpha + \frac{\partial f}{\partial y}(x_0,y_0) \cos \beta$</p>
<p>其中$\alpha,\beta$是⽅向L的⽅向余弦。<br>方向导数的原始定义：$$\lim_{h \to 0} \frac{f(\mathbf{a} + h\mathbf{u}) - f(\mathbf{a})}{h}$$(沿某某方向记得要归一化成长度是一)<br>$$$$</p>
</li>
<li><p><strong>梯度</strong><br>与梯度⽅向相同的⽅向上的⽅向导数值最⼤</p>
</li>
<li><p><strong>全微分</strong></p>
<ul>
<li>有z(x,y)的<strong>全微分</strong><br>$dz &#x3D; \frac{\partial z}{\partial x}  dx + \frac{\partial z}{\partial y}dy$<br>$$\frac{\partial z}{\partial x} &#x3D; -\frac{\frac{\partial F}{\partial x}}{\frac{\partial F}{\partial z}}, \quad \frac{\partial z}{\partial y} &#x3D; -\frac{\frac{\partial F}{\partial y}}{\frac{\partial F}{\partial z}}$$(隐函数)</li>
<li>全微分方程通解是全微分求积</li>
<li>在高等数学中，若被积表达式 $ P  dx + Q  dy $ 是某个函数的全微分，即存在函数 $ u(x, y) $ 使得：<br>$<br>du &#x3D; \frac{\partial u}{\partial x}  dx + \frac{\partial u}{\partial y}  dy &#x3D; P  dx + Q  dy<br>$<br>则曲线积分与路径无关，且积分值等于 $ u(x, y) $ 在终点与起点的函数值之差：<br>$<br>\int_L P  dx + Q  dy &#x3D; u(x_1, y_1) - u(x_0, y_0)<br>$</li>
</ul>
</li>
<li><p><strong>旋度</strong><br><img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E6%97%8B%E5%BA%A6.png" alt="旋度"><br><img src="/%E4%BA%8C%E6%88%98%5C%E6%97%8B%E5%BA%A6.png" alt="旋度"><br>最下面是向量Pi+Qj+Rk中的PQR</p>
</li>
<li><p><strong>梯度散度</strong><br><img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E6%A2%AF%E5%BA%A6%E6%95%A3%E5%BA%A6.png" alt="梯度散度"><br><img src="/%E4%BA%8C%E6%88%98%5C%E6%A2%AF%E5%BA%A6%E6%95%A3%E5%BA%A6.png" alt="梯度散度"></p>
</li>
<li><p><strong>质心</strong><br>求质⼼坐标即以坐标为权重对质量求平均。例如<br><img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E8%B4%A8%E5%BF%83.png" alt="质心"><br><img src="/%E4%BA%8C%E6%88%98%5C%E8%B4%A8%E5%BF%83.png" alt="质心"></p>
</li>
<li><p>多元函数极值问题<br>hessian矩阵: 对x偏导平方乘以对y偏导平方-对x,y二阶导的平方</p>
</li>
<li><p>转动惯量:<br>$I_z&#x3D;\int_C(x^2+y^2)dm&#x3D;I_z&#x3D;\int_C(x^2+y^2)\rho ds$</p>
</li>
<li><p>极值:二元函数极值满足:$\frac{\partial f(x,y)}{\partial x}&#x3D;0$,$\frac{\partial f(x,y)}{\partial y}&#x3D;0$<br>且在该点有$A&#x3D;\frac{\partial^2f}{\partial x^2};B&#x3D;\frac{\partial^2f}{\partial xy};C&#x3D;\frac{\partial^2f}{\partial y^2}$<br>满足:<br>$AC-B^2&lt;0$无极值,<br>$AC-B^2&gt;0,A&gt;0$该点极小值,<br>$AC-B^2&gt;0,A&lt;0$该点极大值</p>
</li>
<li><p>像是知道x&#x3D;x(t)也知道$\frac{dy}{dx}&#x3D;\frac{1}{t}$计算$$\frac{d^2y}{dx^2}&#x3D;\frac{\frac{\frac{dy}{dx}}{dt}}{\frac{dx}{dt}}$$</p>
</li>
<li><p><strong>切平面</strong><br>有$\frac{\partial F}{\partial x}(x - x_0) + \frac{\partial F}{\partial y}(y - y_0) + \frac{\partial F}{\partial z}(z - z_0) &#x3D; 0$</p>
</li>
<li><p>已知$f_x’(x,y)$,y关于x的函数和隐函数$f(x,y)&#x3D;0$;想到对两边同时对x求偏导数</p>
</li>
</ul>
<h2 id="微分方程"><a href="#微分方程" class="headerlink" title="微分方程"></a>微分方程</h2><h3 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h3><ul>
<li>什么是<strong>积分曲线</strong>：<br>积分曲线就是一个微分方程满足条件的通解在坐标系中的表示</li>
<li><strong>齐次方程</strong><br>形如$y’+P(x)y&#x3D;Q(x)$的微分方程<br>有通解<br>$y&#x3D;e^{-\int P(x)dx}(\int Q(x)e^{\int {P(x)dx})}dx+C)$</li>
<li>如果$\frac{dy}{dx}$求不出来,不妨试试$\frac{dx}{dy}$</li>
<li><strong>伯努利方程</strong><br>有$\frac{dy}{dx}+P(x)y&#x3D;Q(x)y^n$<br>设$z&#x3D;y^{1-n}$,就可以化成齐次方程求解</li>
<li><strong>常系数齐次微分方程的解</strong></li>
<li><code>只介绍根为虚数的情况</code>有$y’’-2y’+5y&#x3D;0$根为$1±2i$有$\alpha&#x3D;1,\beta&#x3D;2;解为e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)$</li>
<li><strong>常系数非齐次微分方程的解</strong><br><code>这个地方我自己如果是纯y&#39;&#39;+py&#39;+qy=P_m(x)e^x我自己搞不懂,于是就举个例子说明</code><br>$y’’+y’-2y&#x3D;2e^x$求通解<br><strong>首先</strong>化成$y’’+y’-2y&#x3D;0$有$r_1&#x3D;1,r_2&#x3D;-2$<br>有齐次通解:$y&#x3D;C_1e^x+C_2e^{-2x}$,<br><strong>然后</strong>设非齐次微分方程特解为$Q_m(x)x^ke^{\lambda x}$<br>有$Q_m(x)$是最高次幂与$R_m(x)$相同的多项式,<br>$k&#x3D;0(\lambda ≠ r_1,r_2 );k&#x3D;1(\lambda &#x3D; r_1或r_2 );k&#x3D;2(\lambda &#x3D; r_1&#x3D;r_2 )$<br>上述特解为$$Axe^{x}$$<br><code>如果一开始的式子是2xe^x,则特解是(Ax+B)xe^&#123;x&#125;</code><br>最后求导代入到一开始的式子中:<br>$特解:\frac23xe^x$<br>$通解:y&#x3D;C_1e^x+C_2e^{-2x}+\frac23xe^x$</li>
</ul>
<h3 id="相关习题"><a href="#相关习题" class="headerlink" title="相关习题"></a>相关习题</h3><ul>
<li>关于$xy&#x3D;C_1e^x+C_2e^{-x}$<br><strong>微分方程最后要化简成只包含x，y，dx，dy的式子</strong><br>因此对上式x进行两次求导<br>第一次：$x \frac{dy}{dx} + y &#x3D; C_1 e^x - C_2 e^{-x}$<br>第二次：$x \frac{d^2y}{dx^2} + 2 \frac{dy}{dx} &#x3D; C_1 e^x + C_2 e^{-x}$<br>通过联立原方程和第二次导数的结果，可以消去 $ C_1  和 C_2 $，最后得到：<br>$xy &#x3D; x \frac{d^2y}{dx^2} + 2 \frac{dy}{dx}$</li>
<li>像是$\lim_{x\rightarrow\infty} e^{\frac1x}(2x-1)-2x$不能直接带入1&#x2F;x为0算出得-1.而是要拆开化简.</li>
</ul>
<h2 id="多重积分"><a href="#多重积分" class="headerlink" title="多重积分"></a>多重积分</h2><h3 id="二重积分"><a href="#二重积分" class="headerlink" title="二重积分"></a>二重积分</h3><ul>
<li>极坐标<br><img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E6%9E%81%E5%9D%90%E6%A0%87.png" alt="二重积分极坐标"><br><img src="/%E4%BA%8C%E6%88%98%5C%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86%E6%9E%81%E5%9D%90%E6%A0%87.png" alt="二重积分极坐标"><br>其中$x&#x3D;rcos\theta,y&#x3D;rsin\theta,后面加上rdrd\theta$</li>
<li>二重积分中值定理:f(x,y)任意一点$(\xi,\mu)$有$\iint_Df(x,y)d\sigma&#x3D;S_Df(\xi,\mu)$,$S_D$是该二重积分所围成的闭区间的面积</li>
<li>x+y≥sin(x+y)&#x2F;&#x2F;x≥sinx</li>
</ul>
<h3 id="三重积分"><a href="#三重积分" class="headerlink" title="三重积分"></a>三重积分</h3><ul>
<li>柱坐标<br>   <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E6%9F%B1%E5%9D%90%E6%A0%87.png" alt="三重积分柱坐标"><br>   <img src="/%E4%BA%8C%E6%88%98%5C%E6%9F%B1%E5%9D%90%E6%A0%87.png" alt="三重积分柱坐标"></li>
<li>球坐标<br>  <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E7%90%83%E5%9D%90%E6%A0%87.png" alt="三重积分球坐标"><br>  <img src="/%E4%BA%8C%E6%88%98%5C%E7%90%83%E5%9D%90%E6%A0%87.png" alt="三重积分球坐标"><br>  $dV &#x3D; \rho^2sin\phi d\rho d\phi d\theta$</li>
</ul>
<h3 id="曲线积分"><a href="#曲线积分" class="headerlink" title="曲线积分:"></a>曲线积分:</h3><ul>
<li>第⼀型曲线积分<br>  格式为$x&#x3D;u(t),y&#x3D;v(t)$<br>  曲线积分为:<img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86.png" alt="第一类曲线积分.png"><img src="/%E4%BA%8C%E6%88%98%5C%E7%AC%AC%E4%B8%80%E7%B1%BB%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86.png" alt="第一类曲线积分.png"></li>
</ul>
<h4 id="闭合曲线积分"><a href="#闭合曲线积分" class="headerlink" title="闭合曲线积分:"></a>闭合曲线积分:</h4><ul>
<li>平面曲线:<br>  <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E5%B9%B3%E9%9D%A2%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF.png" alt="平面闭合曲线"><br>  <img src="/%E4%BA%8C%E6%88%98%5C%E5%B9%B3%E9%9D%A2%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF.png" alt="平面闭合曲线"></li>
<li>空间曲线:<br>  <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E7%A9%BA%E9%97%B4%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF.png" alt="空间闭合曲线"><br>  <img src="/%E4%BA%8C%E6%88%98%5C%E7%A9%BA%E9%97%B4%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF.png" alt="空间闭合曲线"></li>
</ul>
<h3 id="曲面积分一般形式"><a href="#曲面积分一般形式" class="headerlink" title="曲面积分一般形式:"></a>曲面积分一般形式:</h3><p>  <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%861.png" alt="曲面积分一般形式"><br>  <img src="/%E4%BA%8C%E6%88%98%5C%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%861.png" alt="曲面积分一般形式"></p>
<h4 id="闭合曲面积分"><a href="#闭合曲面积分" class="headerlink" title="闭合曲面积分"></a>闭合曲面积分</h4><p>  <img src="/2025/05/09/%E4%BA%8C%E6%88%98/%E9%97%AD%E5%90%88%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.png" alt="闭合曲面积分"><br>  <img src="/%E4%BA%8C%E6%88%98%5C%E9%97%AD%E5%90%88%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86.png" alt="闭合曲面积分"></p>
<h3 id="拉格朗日"><a href="#拉格朗日" class="headerlink" title="拉格朗日"></a>拉格朗日</h3><p>  <code>适用于有限制条件的求最小值</code><br>  $F(x,y,z,\lambda)&#x3D;F(x,y,y)+\lambda(限制条件)$<br>  对上述四个求导并&#x3D;0,得到结果即是节点</p>
<h2 id="无穷级数"><a href="#无穷级数" class="headerlink" title="无穷级数"></a>无穷级数</h2><p>分为序列级数和数列级数,总而言之都是证明两种级数最后都收敛于一个值<br><strong>序列收敛的辨别方法:</strong><br>1 单调有界性(单调递增且有上界或是单调递减且有下界)<br>2 夹逼定理<br>3 柯西准则:对任意$\epsilon&gt;0,$存在N使得所有$m,n≥N,有|a_m-a_n|&lt;\epsilon$<br><strong>级数收敛的判断:</strong><br>1 比值审敛法:若为正项级数,$\lim_{n\rightarrow\infty}\frac{u_{n+1}}{u_n}&lt;1$收敛<br>2 根植审敛法:$\sqrt[n]{u_n}&lt;1$收敛<br>3 对于交错级数,有莱布尼茨判别法:$u_n≥u_{n+1}$且$u_n在无穷时趋于0$</p>
<ul>
<li><p>等比数列$\sum_{n&#x3D;1}^\infty aq^{n-1}$当q的绝对值&lt;1时,收敛于$\frac1{1-q}$,&gt;1发散</p>
</li>
<li><p>调和级数$\frac1n$发散</p>
</li>
<li><p>p级数$\sum_{n&#x3D;1}^\infty\frac{1}{n^p}$当p&gt;1收敛,p≤1时发散</p>
</li>
<li><p>收敛域:$\lim_{n\rightarrow\infty}|\frac{a_{n-1}}{a_n}|&#x3D;\rho$<br> 那么幂级数收敛半径为$\frac{1}{\rho}&#x3D;\lim_{n\rightarrow\infty}|\frac{a_{n}}{a_{n-1}}|$</p>
</li>
<li><p>如果$\sum a_n^{2n}$收敛,则$\sum a_n^{2n+1}$绝对收敛</p>
</li>
<li><p>收敛定理:无穷级数收敛于两边的绝对值,例如$f(\frac{1}{2}^+)&#x3D;1,f(\frac{1}{2}^-)&#x3D;3,则f(1&#x2F;2)&#x3D;2$</p>
</li>
<li><p>要注意无穷级数展开的首项,例如ln(1+x)如果从n&#x3D;1开始展开,就要考虑n&#x3D;0的情况.</p>
</li>
<li><p>有$f(x)&#x3D;\int f’(x)dx$,比如</p>
</li>
<li><p>$$\sum{\frac{(-1)^nx^{2n+1}}{2n+1}}&#x3D;\sum\int_0^x({\frac{(-1)^nt^{2n+1}}{2n+1}})’dt&#x3D;\sum\int_0^x(-1)^nt^{2n}dt&#x3D;\int_0^x\sum(-1)^nt^{2n}dt&#x3D;\int_0^x\frac{1}{1+t^2}dt&#x3D;arctanx$$</p>
</li>
<li><p>常用展开:<br>$$ e^x &#x3D; \sum_{n&#x3D;0}^{\infty} \frac{x^n}{n!} \quad (-\infty &lt; x &lt; \infty) $$<br>$$ \frac{1}{1-x} &#x3D; \sum_{n&#x3D;0}^{\infty} x^n \quad (-1 &lt; x &lt; 1) $$<br>$$ \frac{1}{1+x} &#x3D; \sum_{n&#x3D;0}^{\infty} (-1)^n x^n \quad (-1 &lt; x &lt; 1) $$<br>$$ \sin x &#x3D; \sum_{n&#x3D;0}^{\infty} (-1)^n \frac{x^{2n+1}}{(2n+1)!} \quad (-\infty &lt; x &lt; \infty) $$<br>$$ \cos x &#x3D; \sum_{n&#x3D;0}^{\infty} (-1)^n \frac{x^{2n}}{(2n)!} \quad (-\infty &lt; x &lt; \infty) $$<br>$$ \tan^{-1} x &#x3D; \sum_{n&#x3D;0}^{\infty} (-1)^n \frac{x^{2n+1}}{2n+1} \quad (-1 \leq x \leq 1) $$<br>$$ \ln(1+x) &#x3D; \sum_{n&#x3D;1}^{\infty} (-1)^{n+1} \frac{x^n}{n} \quad (-1 &lt; x \leq 1) $$<br>$$ \ln(1-x) &#x3D; -\sum_{n&#x3D;1}^{\infty} \frac{x^n}{n} \quad (-1 \leq x &lt; 1) $$</p>
</li>
</ul>
<h3 id="傅里叶级数"><a href="#傅里叶级数" class="headerlink" title="傅里叶级数"></a>傅里叶级数</h3><p>$$ f(x) &#x3D; \frac{a_0}{2} + \sum_{n&#x3D;1}^{\infty} \left( a_n \cos \frac{n\pi x}{L} + b_n \sin \frac{n\pi x}{L} \right) $$<br>其中<br>$$ a_0 &#x3D; \frac{1}{L} \int_{-L}^{L} f(x)  dx $$<br>$$ a_n &#x3D; \frac{1}{L} \int_{-L}^{L} f(x) \cos \frac{n\pi x}{L}  dx \quad (n \geq 1) $$<br>$$ b_n &#x3D; \frac{1}{L} \int_{-L}^{L} f(x) \sin \frac{n\pi x}{L}  dx \quad (n \geq 1) $$</p>
<ul>
<li><strong>余弦级数</strong>:$$ f(x) &#x3D; \frac{a_0}{2} + \sum_{n&#x3D;1}^{\infty} a_n \cos \frac{n\pi x}{L} $$<br>其中<br>$ a_0 &#x3D; \frac{2}{L} \int_{0}^{L} f(x)  dx $<br>$ a_n &#x3D; \frac{2}{L} \int_{0}^{L} f(x) \cos \frac{n\pi x}{L}  dx \quad (n \geq 1) $</li>
<li><strong>正弦级数</strong>:$$ f(x) &#x3D; \sum_{n&#x3D;1}^{\infty} b_n \sin \frac{n\pi x}{L} $$<br>其中<br>$ b_n &#x3D; \frac{2}{L} \int_{0}^{L} f(x) \sin \frac{n\pi x}{L}  dx \quad (n \geq 1) $</li>
</ul>
<h1 id="线性代数"><a href="#线性代数" class="headerlink" title="线性代数"></a>线性代数</h1><h2 id="行列式"><a href="#行列式" class="headerlink" title="行列式"></a>行列式</h2><ul>
<li>$$\begin{matrix}  &amp;  &amp; &amp; a_{1,n} \  &amp; &amp; a_{2,n-1} &amp;  \  &amp; … &amp; \ a_{n,1} &amp;  &amp;  \end{matrix}$$的值为$$(-1)^{\frac{n(n-1)}{2}}a_{1,n}a_{2,n-1}…a_{n,1}$$</li>
<li>范德蒙德行列式<br>$$\begin{matrix}<br>1&amp;1&amp;1&amp;…&amp;1\<br>x_1&amp;x_2&amp;x_3&amp;…&amp;x_n\<br>x_1^2&amp;x_2^2&amp;x_3^2&amp;…&amp;x_n^2\<br>…&amp;…&amp;…&amp;…&amp;…\<br>x_1^n&amp;x_2^n&amp;x_3^n&amp;…&amp;x_n^n\<br>\end{matrix}$$<br>值为$$\prod_{1≤i≤j≤n}(x_j-x_i)$$</li>
</ul>
<h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h2><ul>
<li>行最简矩阵,要求非零行首元均为0;非零行首元所在列其他元素均为0</li>
<li>行列式行列式,像是3×1矩阵,3是行,1是列,像是(1,2,3)^T</li>
</ul>
<h3 id="转置矩阵"><a href="#转置矩阵" class="headerlink" title="转置矩阵"></a>转置矩阵</h3><ul>
<li>$$(kA)^T&#x3D;kA^T$$</li>
<li>$$(A+B)^T&#x3D;A^T+B^T$$</li>
<li>$$(AB)^T&#x3D;B^TA^T$$</li>
</ul>
<h3 id="伴随矩阵"><a href="#伴随矩阵" class="headerlink" title="伴随矩阵"></a>伴随矩阵</h3><ul>
<li>$$AA^*&#x3D;A^*A&#x3D;|A|E$$</li>
<li>$$|A^*|&#x3D;|A|^{n-1}$$</li>
<li>$$(AB)^*&#x3D;B^<em>A^</em>$$</li>
</ul>
<h3 id="逆矩阵"><a href="#逆矩阵" class="headerlink" title="逆矩阵"></a>逆矩阵</h3><ul>
<li>$$(kA)^{-1}&#x3D;\frac1kA^{-1}$$</li>
<li>$$(AB)^{-1}&#x3D;B^{-1}A^{-1}$$</li>
</ul>
<h3 id="分块矩阵"><a href="#分块矩阵" class="headerlink" title="分块矩阵"></a>分块矩阵</h3><p>-<br>$$\begin{matrix}<br>O&amp;A\<br>B&amp;O\<br>\end{matrix}^{-1}&#x3D;\begin{matrix}<br>O&amp;B^{-1}\<br>A^{-1}&amp;O<br>\end{matrix}$$</p>
<p>-<br>$$|\begin{matrix}<br>O&amp;A\<br>B&amp;O\<br>\end{matrix}|&#x3D;(-1)^{mn}AB$$,m,n为方阵A,B的阶数</p>
<h3 id="矩阵的秩"><a href="#矩阵的秩" class="headerlink" title="矩阵的秩!!!"></a>矩阵的秩!!!</h3><ul>
<li>A是m×n矩阵,P,Q分别为m,n阶可逆矩阵.有$r(A)&#x3D;r(PA)&#x3D;r(AQ)&#x3D;r(PAQ)$</li>
<li>矩阵A和B等价有r(A)&#x3D;R(B)</li>
<li>$r(kA)&#x3D;r(A),k≠0$</li>
<li>$当A是m×n,B是n×s,r(AB)≤\min{r(A),r(B)}$</li>
<li>$当A是m×n,B是n×s,有AB&#x3D;O时,则r(A)+r(B)≤n$</li>
<li>当A是m×n,B是m×s,则$\max{r(A),r(B)}\le r(A,B)\le r(A)+r(B)$</li>
<li>当A,B都是m,n矩阵,则$r(A+B)\le r(A,B)\le r(A)+r(B)$</li>
<li></li>
</ul>
<p>$$<br>r(A^*) &#x3D; \left{<br>\begin{aligned}<br>n&amp;,r(A)&#x3D;n\<br>1&amp;,r(A)&#x3D;n-1\<br>0&amp;,r(A)\le n-1<br>\end{aligned}<br>\right.<br>$$</p>
<ul>
<li>例题 $n阶矩阵A有A^2&#x3D;A,证明r(A)+r(A-E)&#x3D;n$<br>$A^2-A&#x3D;0 \rightarrow A(A-E)&#x3D;0 \rightarrow r(A)+r(A-E)\le n$<br>$r(A)+r(A-E) \ge r(A|A-E) \ge r(A-(A-E)) &#x3D;0$</li>
</ul>
<h2 id="线性方程组"><a href="#线性方程组" class="headerlink" title="线性方程组"></a>线性方程组</h2><ul>
<li>基本变量:选取基本变量首先要选取主元列:即单独把主元列提出形成子矩阵的秩&#x3D;r(A)</li>
<li>方程组解的判定:<br>当r(A)&#x3D;n时,$A_{m×n}x&#x3D;0$只有零解<code>唯一解就是零解</code><br>当r(A)&lt;n时,$A_{m×n}x&#x3D;0$有含n-r(A)个自由向量的无穷多组解<br>当r(A)&#x3D;r(A|b)&#x3D;n时,$A_{m×n}x&#x3D;b$有唯一解<br>当r(A)&#x3D;r(A|b)&lt;n时,$A_{m×n}x&#x3D;b$有含n-r(A)个自由向量的无穷多组解<br>当r(A)!&#x3D;r(A|b),$A_{m×n}x&#x3D;b$无解</li>
</ul>
<h3 id="线性相关-无关-表示"><a href="#线性相关-无关-表示" class="headerlink" title="线性相关&#x2F;无关&#x2F;表示"></a>线性相关&#x2F;无关&#x2F;表示</h3><ul>
<li>n维向量组无关$a_1,a_2…a_n\rightarrow |A|&#x3D;0$</li>
<li>$\beta 能由a_1,a_2…a_n$线性表示$\rightarrow (a_1,a_2…a_n)(k_1,k_2…k_n)^T&#x3D;\beta \rightarrow r(a_1,a_2…a_n)&#x3D;r(a_1,a_2…a_n,\beta)$</li>
<li>包含零向量的向量组线性相关,两个成比例的向量线性相关</li>
<li>部分相关能推整体相关,整体无关能推部分无关</li>
<li>向量个数大于向量维度必有关</li>
<li>极大无关组所含向量的个数即为向量组的秩</li>
<li>向量组等价 ⟹ 秩相同<br>秩相同 + 互相线性表示 ⟺ 向量组等价<br>秩相同 ⟺ 矩阵等价</li>
<li>向量组A能由向量组B表示⟹ r(B)&gt;r(A)</li>
</ul>
<h3 id="基础解系与解的结构"><a href="#基础解系与解的结构" class="headerlink" title="基础解系与解的结构"></a>基础解系与解的结构</h3><ul>
<li><strong>齐次线性方程组</strong>步骤:先化简成行最简矩阵,找主元列,其为主变量,剩下的是自由基.有n-r(A)个,自由基去正交底座,上面按位取反</li>
<li>例题:<br>$\begin{matrix}<br>1&amp;0&amp;1&amp;1&amp;3\<br>0&amp;1&amp;0&amp;0&amp;-2<br>\end{matrix}<br>$<br>取自由基 $\begin{matrix}1\0\0\end{matrix}$,$\begin{matrix}0\1\0\end{matrix}$,$\begin{matrix}0\0\1\end{matrix}$<br>有秩为2,$x_1,x_2$是主元列<br>所以基础解系是:$k_1\begin{matrix}-1\0\1\0\0\end{matrix}+k_2\begin{matrix}-1\0\0\1\0\end{matrix}+k_3\begin{matrix}-3\2\0\0\1\end{matrix}$</li>
<li><strong>非齐次线性方程组</strong>步骤:列为(A|b),先把A化简成行最简矩阵,变换后的B就是通解</li>
<li>解的性质:<br>有$\eta_1,\eta_2都是Ax&#x3D;b的解,有\eta_1-\eta_2是导出组Ax&#x3D;0$<br>有$\eta_1,\eta_2…\eta_n都是Ax&#x3D;b的解,$<br>$当k_1+k_2+…+k_n&#x3D;1时,k_1\eta_1+k_2\eta_2+…+k_n\eta_n是Ax&#x3D;b的解$<br>$当k_1+k_2+…+k_n&#x3D;0时,k_1\eta_1+k_2\eta_2+…+k_n\eta_n是Ax&#x3D;0的解$</li>
<li>判断是否为通解:先看齐次解是不是解,个数是否一致,是否<strong>线性无关</strong>再看非齐次相加是否为1</li>
</ul>
<h3 id="施密特正交"><a href="#施密特正交" class="headerlink" title="施密特正交"></a>施密特正交</h3><p>$$<br>\beta_1 &#x3D; x_1\<br>\beta_2 &#x3D; x_2 -\frac{(x_2,\beta_1)}{(\beta_1,\beta_1)}\beta_1\<br>\beta_3 &#x3D; x_3 -\frac{(x_3,\beta_2)}{(\beta_2,\beta_2)}\beta_2-\frac{(x_3,\beta_1)}{(\beta_1,\beta_1)}\beta_1<br>$$</p>
<h2 id="矩阵相似理论"><a href="#矩阵相似理论" class="headerlink" title="矩阵相似理论"></a>矩阵相似理论</h2><ul>
<li>特征值和特征向量的定义:有$Ax&#x3D;\lambda x;称\lambda$是矩阵A的特征值,x是对应于特征值$\lambda$的特征向量</li>
<li>求特征值:$(\lambda E-A)x&#x3D;0$<br>首先:有解,则$|\lambda E-A|!&#x3D;0$,按照解出来的$\lambda$求对应的特征向量就好</li>
<li>特征值之和为矩阵A的迹,即对角线之和</li>
<li>特征值之积为矩阵A的行列式</li>
<li>求解特征方程$f(\lambda)&#x3D;|\lambda E-A|$,得到n个根,n个根就是矩阵A的n个特征值,根的重数称之为代数重数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">设特征多项式为 f(\lambda) = (\lambda - 3)^3 (\lambda + 1)：  </span><br><span class="line">   - 根lambda = 3 出现 3 次，根lambda=3代数重数为（三重根） </span><br><span class="line">   - 根 lambda = -1出现 1 次，根lambda=1代数重数为1（单根）  </span><br></pre></td></tr></table></figure>
<ul>
<li>$(\lambda E-A)x&#x3D;0$所对应的基础解系有p个线性无关的向量,p为几何重数</li>
</ul>
<table>
<thead>
<tr>
<th>矩阵</th>
<th>$A$</th>
<th>$kA+bE$</th>
<th>$A^k$</th>
<th>$f(A)$</th>
<th>$A^-{1}$</th>
<th>$A^*$</th>
<th>$P^{-1}AP$</th>
</tr>
</thead>
<tbody><tr>
<td>特征值</td>
<td>$\lambda$</td>
<td>$k+b$</td>
<td>$\lambda^k$</td>
<td>$f(\lambda)$</td>
<td>$\frac{1}{\lambda}$</td>
<td>$\frac{|A|}{\lambda}$</td>
<td>$\lambda$</td>
</tr>
<tr>
<td>特征向量</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>x</td>
<td>$P^{-1}x$</td>
</tr>
</tbody></table>
<ul>
<li>$A^T$的特征值也是$\lambda$,但是特征向量需要重新计算</li>
<li>秩为1矩阵: $A&#x3D;\alpha\beta^T;tr(A)&#x3D;\alpha^T\beta$</li>
<li>矩阵相似,A<del>B 有:<br>$|\lambda E-A|&#x3D;|\lambda E-B|\rightarrow |A|&#x3D;|B|;tr(A)&#x3D;tr(B)$<br>有$r(A)&#x3D;r(B);r(\lambda E-A)&#x3D;r(\lambda E-B)$<br>$A^T$ ~ $B^T;A^{-1}$</del>$B^{-1};f(A^{-1})$ ~ $f(B^{-1})$</li>
</ul>
<h2 id="矩阵相似对角化"><a href="#矩阵相似对角化" class="headerlink" title="矩阵相似对角化"></a>矩阵相似对角化</h2><p>定义:$A(a_1,a_2,a_3…a_n)&#x3D;(\lambda_1a_1,\lambda_2a_2…\lambda_na_n)$当$a_1,a_2,a_3…a_n$线性无关,记$P&#x3D;(a_1,a_2,a_3…a_n)$有$P^{-1}AP&#x3D;\Lambda$</p>
<ul>
<li>充要:A恰有n个线性无关的特征向量,即A每个特征值的几何重数等于其代数重数</li>
<li>充分:<br>有n个不同的特征值;<br>A为实对称矩阵<br>$A^2&#x3D;A$<br>$A^2&#x3D;E$<br>秩为一矩阵迹不为0,就可以相似对角化</li>
<li>必要:<br>$|A|&#x3D;|\Lambda|$<br>$tr(A)&#x3D;tr(\Lambda)$<br>$r(A)&#x3D;r(\Lambda)$</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Morgenro</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2025/05/09/%E4%BA%8C%E6%88%98/">http://example.com/2025/05/09/%E4%BA%8C%E6%88%98/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="http://example.com" target="_blank">Morgenro's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></div><div class="post-share"><div class="social-share" data-image="/img/AiHaibara1.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related full-width" href="/2025/07/15/financial-risk-LLM/" title="financial-risk-LLM"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">financial-risk-LLM</div></div><div class="info-2"><div class="info-item-1">金融风险大模型训练及系统开发</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/AiHaibara1.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Morgenro</div><div class="author-info-description"></div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">7</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">8</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Morgenro/"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#408"><span class="toc-number">1.</span> <span class="toc-text">408</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">线性表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.2.</span> <span class="toc-text">栈、队列、数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">1.1.3.</span> <span class="toc-text">串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.4.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.1.4.1.</span> <span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-number">1.1.4.2.</span> <span class="toc-text">树和森林</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.1.4.3.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.1.5.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%82%A8%E5%AD%98"><span class="toc-number">1.1.5.1.</span> <span class="toc-text">图的储存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.1.5.2.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.5.3.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.1.5.3.1.</span> <span class="toc-text">最小生成树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.5.3.2.</span> <span class="toc-text">最短路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.5.3.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84"><span class="toc-number">1.1.5.3.4.</span> <span class="toc-text">关键路径</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.1.</span> <span class="toc-text">顺序查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.1.1.</span> <span class="toc-text">有序线性表的顺序查找</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.2.</span> <span class="toc-text">折半查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.3.</span> <span class="toc-text">分块查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.1.6.4.</span> <span class="toc-text">树形查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91"><span class="toc-number">1.1.6.4.1.</span> <span class="toc-text">二叉排序树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91"><span class="toc-number">1.1.6.4.2.</span> <span class="toc-text">二叉平衡树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91"><span class="toc-number">1.1.6.4.3.</span> <span class="toc-text">红黑树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">1.1.6.4.4.</span> <span class="toc-text">B树和B+树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Hash"><span class="toc-number">1.1.6.4.5.</span> <span class="toc-text">Hash</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#Hash%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.6.4.5.1.</span> <span class="toc-text">Hash的构造方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#Hash%E7%9A%84%E5%A4%84%E7%90%86%E5%86%B2%E7%AA%81%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.6.4.5.2.</span> <span class="toc-text">Hash的处理冲突方法</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.2.</span> <span class="toc-text">交换排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.3.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.4.</span> <span class="toc-text">二路归并排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.5.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.6.</span> <span class="toc-text">外部排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95"><span class="toc-number">1.1.7.6.1.</span> <span class="toc-text">归并排序算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E4%B8%8E%E8%B4%A5%E8%80%85%E6%A0%91"><span class="toc-number">1.1.7.6.2.</span> <span class="toc-text">多路归并排序与败者树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BD%AE%E6%8D%A2-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.1.7.6.3.</span> <span class="toc-text">置换-选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E4%BD%B3%E5%BD%92%E5%B9%B6%E6%A0%91"><span class="toc-number">1.1.7.6.4.</span> <span class="toc-text">最佳归并树</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">计算机组成原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机系统概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">计算机层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%BD%AF%E4%BB%B6"><span class="toc-number">1.2.1.1.1.</span> <span class="toc-text">计算机软件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">计算机的性能指标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.</span> <span class="toc-text">数据的表示和运算</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E6%95%B0%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">整数类型和类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E7%94%B5%E5%99%A8"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">运算方法和运算电器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9A%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.2.1.</span> <span class="toc-text">定点数的表示和运算</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E8%BF%90%E7%AE%97"><span class="toc-number">1.2.2.2.2.</span> <span class="toc-text">浮点数的表示和运算</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.2.3.</span> <span class="toc-text">存储系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">存储器概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.2.3.1.1.</span> <span class="toc-text">存储器的分类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.3.1.2.</span> <span class="toc-text">存储器的性能指标</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">主存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#SRAM%E5%92%8CDRAM"><span class="toc-number">1.2.3.2.1.</span> <span class="toc-text">SRAM和DRAM</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ROM-%E5%8F%AA%E8%AF%BB%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.2.2.</span> <span class="toc-text">ROM(只读存储器)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%84%E6%88%90"><span class="toc-number">1.2.3.2.3.</span> <span class="toc-text">主存储器的基本组成</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E5%9D%97%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.2.4.</span> <span class="toc-text">多模块存储器</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8%E5%92%8CCPU%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">主存储器和CPU的链接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BB%E5%AD%98%E5%AE%B9%E9%87%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">1.2.3.3.1.</span> <span class="toc-text">主存容量的扩展</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E8%8A%AF%E7%89%87%E7%9A%84%E5%9C%B0%E5%9D%80%E5%88%86%E9%85%8D%E5%92%8C%E7%89%87%E9%80%89"><span class="toc-number">1.2.3.3.2.</span> <span class="toc-text">储存芯片的地址分配和片选</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%82%A8%E5%AD%98%E5%99%A8%E5%92%8CCPU%E7%9A%84%E9%93%BE%E6%8E%A5"><span class="toc-number">1.2.3.3.3.</span> <span class="toc-text">储存器和CPU的链接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">外部存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.4.1.</span> <span class="toc-text">磁盘存储器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BA%E6%80%81%E7%A1%AC%E7%9B%98"><span class="toc-number">1.2.3.4.2.</span> <span class="toc-text">固态硬盘</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%86%B2%E5%AD%98%E5%82%A8%E5%99%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">高速缓冲存储器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Cache%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.3.5.1.</span> <span class="toc-text">Cache的基本工作原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cache%E5%92%8C%E4%B8%BB%E5%AD%98%E7%9A%84%E6%98%A0%E5%B0%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.2.3.5.2.</span> <span class="toc-text">Cache和主存的映射方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cache%E4%B8%AD%E4%B8%BB%E5%AD%98%E5%9D%97%E7%9A%84%E6%9B%BF%E6%8D%A2%E7%AE%97%E6%B3%95"><span class="toc-number">1.2.3.5.3.</span> <span class="toc-text">Cache中主存块的替换算法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Cache%E7%9A%84%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98"><span class="toc-number">1.2.3.5.4.</span> <span class="toc-text">Cache的一致性问题</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C"><span class="toc-number">1.4.</span> <span class="toc-text">计算机网络</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6"><span class="toc-number">2.</span> <span class="toc-text">高等数学</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD"><span class="toc-number">2.1.</span> <span class="toc-text">函数极限与连续</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E6%9E%81%E9%99%90"><span class="toc-number">2.1.1.</span> <span class="toc-text">常用极限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%B0%E5%8B%92%E5%85%AC%E5%BC%8F-%E5%9C%A80%E5%A4%84"><span class="toc-number">2.1.2.</span> <span class="toc-text">泰勒公式(在0处)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93"><span class="toc-number">2.1.3.</span> <span class="toc-text">题目总结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%B4%E6%96%AD%E7%82%B9"><span class="toc-number">2.1.4.</span> <span class="toc-text">间断点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%88%97%E6%9E%81%E9%99%90"><span class="toc-number">2.2.</span> <span class="toc-text">数列极限</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%88%86%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86"><span class="toc-number">2.2.1.</span> <span class="toc-text">微分中值定理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%81%E6%98%8E%EF%BC%9A"><span class="toc-number">2.2.1.1.</span> <span class="toc-text">证明：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A7%AF%E5%88%86%E5%BE%AE%E5%88%86"><span class="toc-number">2.3.</span> <span class="toc-text">积分微分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%9F%BA%E6%9C%AC%E7%A7%AF%E5%88%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">一、基本积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%AD%A3%E5%88%87%E4%B8%8E%E4%BD%99%E5%88%87%E7%A7%AF%E5%88%86"><span class="toc-number">2.3.2.</span> <span class="toc-text">二、正切与余切积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%B9%B3%E6%96%B9%E5%BD%A2%E5%BC%8F%E7%A7%AF%E5%88%86"><span class="toc-number">2.3.3.</span> <span class="toc-text">三、平方形式积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E7%A7%AF%E5%88%86"><span class="toc-number">2.3.4.</span> <span class="toc-text">四、其他重要积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%85%B6%E4%BB%96%E9%87%8D%E8%A6%81%E5%85%AC%E5%BC%8F"><span class="toc-number">2.3.5.</span> <span class="toc-text">五、其他重要公式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6"><span class="toc-number">2.4.</span> <span class="toc-text">一元函数微分学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E5%87%A0%E4%BD%95%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">一元函数微分学-几何应用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E4%B8%AD%E5%80%BC%E5%AE%9A%E7%90%86%EF%BC%8C%E5%BE%AE%E5%88%86%E7%AD%89%E5%BC%8F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F"><span class="toc-number">2.4.2.</span> <span class="toc-text">一元函数微分学-中值定理，微分等式与不等式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6-%E7%89%A9%E7%90%86%E5%BA%94%E7%94%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">一元函数微分学-物理应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6"><span class="toc-number">2.5.</span> <span class="toc-text">一元函数积分学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%80%A7%E8%B4%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">一元函数积分学的概念和性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%85%83%E5%87%BD%E6%95%B0%E7%A7%AF%E5%88%86%E5%AD%A6%E7%9A%84%E8%AE%A1%E7%AE%97"><span class="toc-number">2.5.2.</span> <span class="toc-text">一元函数积分学的计算</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%85%83%E5%87%BD%E6%95%B0%E5%BE%AE%E5%88%86%E5%AD%A6"><span class="toc-number">2.6.</span> <span class="toc-text">多元函数微分学</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">微分方程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5"><span class="toc-number">2.7.1.</span> <span class="toc-text">基础概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%B9%A0%E9%A2%98"><span class="toc-number">2.7.2.</span> <span class="toc-text">相关习题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.</span> <span class="toc-text">多重积分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E9%87%8D%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.1.</span> <span class="toc-text">二重积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89%E9%87%8D%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.2.</span> <span class="toc-text">三重积分</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.3.</span> <span class="toc-text">曲线积分:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%90%88%E6%9B%B2%E7%BA%BF%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.3.1.</span> <span class="toc-text">闭合曲线积分:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86%E4%B8%80%E8%88%AC%E5%BD%A2%E5%BC%8F"><span class="toc-number">2.8.4.</span> <span class="toc-text">曲面积分一般形式:</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%90%88%E6%9B%B2%E9%9D%A2%E7%A7%AF%E5%88%86"><span class="toc-number">2.8.4.1.</span> <span class="toc-text">闭合曲面积分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5"><span class="toc-number">2.8.5.</span> <span class="toc-text">拉格朗日</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A0%E7%A9%B7%E7%BA%A7%E6%95%B0"><span class="toc-number">2.9.</span> <span class="toc-text">无穷级数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%82%85%E9%87%8C%E5%8F%B6%E7%BA%A7%E6%95%B0"><span class="toc-number">2.9.1.</span> <span class="toc-text">傅里叶级数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0"><span class="toc-number">3.</span> <span class="toc-text">线性代数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E5%88%97%E5%BC%8F"><span class="toc-number">3.1.</span> <span class="toc-text">行列式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.</span> <span class="toc-text">矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E7%BD%AE%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.1.</span> <span class="toc-text">转置矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%B4%E9%9A%8F%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.2.</span> <span class="toc-text">伴随矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%86%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.3.</span> <span class="toc-text">逆矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E7%9F%A9%E9%98%B5"><span class="toc-number">3.2.4.</span> <span class="toc-text">分块矩阵</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9A%84%E7%A7%A9"><span class="toc-number">3.2.5.</span> <span class="toc-text">矩阵的秩!!!</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E6%96%B9%E7%A8%8B%E7%BB%84"><span class="toc-number">3.3.</span> <span class="toc-text">线性方程组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%9B%B8%E5%85%B3-%E6%97%A0%E5%85%B3-%E8%A1%A8%E7%A4%BA"><span class="toc-number">3.3.1.</span> <span class="toc-text">线性相关&#x2F;无关&#x2F;表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E8%A7%A3%E7%B3%BB%E4%B8%8E%E8%A7%A3%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.3.2.</span> <span class="toc-text">基础解系与解的结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4"><span class="toc-number">3.3.3.</span> <span class="toc-text">施密特正交</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E7%90%86%E8%AE%BA"><span class="toc-number">3.4.</span> <span class="toc-text">矩阵相似理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E9%98%B5%E7%9B%B8%E4%BC%BC%E5%AF%B9%E8%A7%92%E5%8C%96"><span class="toc-number">3.5.</span> <span class="toc-text">矩阵相似对角化</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/08/02/markdown%E8%AF%AD%E6%B3%95/" title="Markdown语法">Markdown语法</a><time datetime="2025-08-01T16:00:00.000Z" title="发表于 2025-08-02 00:00:00">2025-08-02</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/29/%E5%B9%B3%E6%9D%BF%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/" title="平板远程连接云服务器">平板远程连接云服务器</a><time datetime="2025-07-29T11:54:07.000Z" title="发表于 2025-07-29 19:54:07">2025-07-29</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/25/7%E6%9C%88%E9%AB%98%E4%B8%AD%E6%9C%8B%E5%8F%8B%E6%9D%A5%E8%AE%BF%E8%AE%B0/" title="7月高中朋友来访记">7月高中朋友来访记</a><time datetime="2025-07-25T13:42:09.000Z" title="发表于 2025-07-25 21:42:09">2025-07-25</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/16/MoeChat/" title="MoeChat">MoeChat</a><time datetime="2025-07-16T14:40:15.000Z" title="发表于 2025-07-16 22:40:15">2025-07-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2025/07/15/%E4%B8%BA%E4%BD%A0%E7%9A%84hexo%E6%B7%BB%E5%8A%A0%E4%B8%8D%E6%AD%A2%E4%B8%80%E4%B8%AA%E8%AF%84%E8%AE%BA%E5%8C%BA/" title="为你的hexo添加不止一个评论区">为你的hexo添加不止一个评论区</a><time datetime="2025-07-15T14:03:04.000Z" title="发表于 2025-07-15 22:03:04">2025-07-15</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By Morgenro</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'all',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const getGiscusTheme = theme => theme === 'dark' ? 'dark' : 'light'

  const createScriptElement = config => {
    const ele = document.createElement('script')
    Object.entries(config).forEach(([key, value]) => {
      ele.setAttribute(key, value)
    })
    return ele
  }

  const loadGiscus = (el = document, key) => {
    const mappingConfig = isShuoshuo
      ? { 'data-mapping': 'specific', 'data-term': key }
      : { 'data-mapping': (option && option['data-mapping']) || 'pathname' }

    const giscusConfig = {
      src: 'https://giscus.app/client.js',
      'data-repo': 'Morgenro/Morgenro.github.io',
      'data-repo-id': 'R_kgDOOnQMCg',
      'data-category-id': 'DIC_kwDOOnQMCs4Cs90C',
      'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
      'data-reactions-enabled': '1',
      crossorigin: 'anonymous',
      async: true,
      ...option,
      ...mappingConfig
    }

    const scriptElement = createScriptElement(giscusConfig)

    el.querySelector('#giscus-wrap').appendChild(scriptElement)

    if (isShuoshuo) {
      window.shuoshuoComment.destroyGiscus = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }
  }

  const changeGiscusTheme = theme => {
    const iframe = document.querySelector('#giscus-wrap iframe')
    if (iframe) {
      const message = {
        giscus: {
          setConfig: {
            theme: getGiscusTheme(theme)
          }
        }
      }
      iframe.contentWindow.postMessage(message, 'https://giscus.app')
    }
  }

  btf.addGlobalFn('themeChange', changeGiscusTheme, 'giscus')

  if (isShuoshuo) {
    'Giscus' === 'Giscus'
      ? window.shuoshuoComment = { loadComment: loadGiscus }
      : window.loadOtherComment = loadGiscus
    return
  }

  if ('Giscus' === 'Giscus' || !false) {
    if (false) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
    else loadGiscus()
  } else {
    window.loadOtherComment = loadGiscus
  }
})()</script></div><script src="/js/life-pages.js?1"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>